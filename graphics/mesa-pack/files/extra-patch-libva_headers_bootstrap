--- /dev/null
+++ src/gallium/state_trackers/va/va/va.h
@@ -0,0 +1,2856 @@
+/*
+ * Copyright (c) 2007-2009 Intel Corporation. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+/*
+ * Video Acceleration (VA) API Specification
+ *
+ * Rev. 0.30
+ * <jonathan.bian@intel.com>
+ *
+ * Revision History:
+ * rev 0.10 (12/10/2006 Jonathan Bian) - Initial draft
+ * rev 0.11 (12/15/2006 Jonathan Bian) - Fixed some errors
+ * rev 0.12 (02/05/2007 Jonathan Bian) - Added VC-1 data structures for slice level decode
+ * rev 0.13 (02/28/2007 Jonathan Bian) - Added GetDisplay()
+ * rev 0.14 (04/13/2007 Jonathan Bian) - Fixed MPEG-2 PictureParameter structure, cleaned up a few funcs.
+ * rev 0.15 (04/20/2007 Jonathan Bian) - Overhauled buffer management
+ * rev 0.16 (05/02/2007 Jonathan Bian) - Added error codes and fixed some issues with configuration
+ * rev 0.17 (05/07/2007 Jonathan Bian) - Added H.264/AVC data structures for slice level decode.
+ * rev 0.18 (05/14/2007 Jonathan Bian) - Added data structures for MPEG-4 slice level decode 
+ *                                       and MPEG-2 motion compensation.
+ * rev 0.19 (08/06/2007 Jonathan Bian) - Removed extra type for bitplane data.
+ * rev 0.20 (08/08/2007 Jonathan Bian) - Added missing fields to VC-1 PictureParameter structure.
+ * rev 0.21 (08/20/2007 Jonathan Bian) - Added image and subpicture support.
+ * rev 0.22 (08/27/2007 Jonathan Bian) - Added support for chroma-keying and global alpha.
+ * rev 0.23 (09/11/2007 Jonathan Bian) - Fixed some issues with images and subpictures.
+ * rev 0.24 (09/18/2007 Jonathan Bian) - Added display attributes.
+ * rev 0.25 (10/18/2007 Jonathan Bian) - Changed to use IDs only for some types.
+ * rev 0.26 (11/07/2007 Waldo Bastian) - Change vaCreateBuffer semantics
+ * rev 0.27 (11/19/2007 Matt Sottek)   - Added DeriveImage
+ * rev 0.28 (12/06/2007 Jonathan Bian) - Added new versions of PutImage and AssociateSubpicture 
+ *                                       to enable scaling
+ * rev 0.29 (02/07/2008 Jonathan Bian) - VC1 parameter fixes,
+ *                                       added VA_STATUS_ERROR_RESOLUTION_NOT_SUPPORTED
+ * rev 0.30 (03/01/2009 Jonathan Bian) - Added encoding support for H.264 BP and MPEG-4 SP and fixes
+ *                                       for ISO C conformance.
+ * rev 0.31 (09/02/2009 Gwenole Beauchesne) - VC-1/H264 fields change for VDPAU and XvBA backend
+ *                                       Application needs to relink with the new library.
+ *
+ * rev 0.31.1 (03/29/2009)              - Data structure for JPEG encode
+ * rev 0.31.2 (01/13/2011 Anthony Pabon)- Added a flag to indicate Subpicture coordinates are screen
+ *                                        screen relative rather than source video relative.
+ * rev 0.32.0 (01/13/2011 Xiang Haihao) - Add profile into VAPictureParameterBufferVC1
+ *                                        update VAAPI to 0.32.0
+ *
+ * Acknowledgements:
+ *  Some concepts borrowed from XvMC and XvImage.
+ *  Waldo Bastian (Intel), Matt Sottek (Intel),  Austin Yuan (Intel), and Gwenole Beauchesne (SDS)
+ *  contributed to various aspects of the API.
+ */
+
+/**
+ * \file va.h
+ * \brief The Core API
+ *
+ * This file contains the \ref api_core "Core API".
+ */
+
+#ifndef _VA_H_
+#define _VA_H_
+
+#include <stddef.h>
+#include <stdint.h>
+//#include <va/va_version.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \mainpage Video Acceleration (VA) API
+ *
+ * \section intro Introduction
+ *
+ * The main motivation for VA-API (Video Acceleration API) is to
+ * enable hardware accelerated video decode and encode at various
+ * entry-points (VLD, IDCT, Motion Compensation etc.) for the
+ * prevailing coding standards today (MPEG-2, MPEG-4 ASP/H.263, MPEG-4
+ * AVC/H.264, VC-1/VMW3, and JPEG).
+ *
+ * VA-API is split into several modules:
+ * - \ref api_core
+ * - \ref api_enc_h264
+ * - \ref api_vpp
+ */
+
+/**
+ * \defgroup api_core Core API
+ *
+ * @{
+ */
+
+/**
+Overview 
+
+The VA API is intended to provide an interface between a video decode/encode/display
+application (client) and a hardware accelerator (server), to off-load 
+video decode/encode/display operations from the host to the hardware accelerator at various 
+entry-points.
+
+The basic operation steps are:
+
+- Negotiate a mutually acceptable configuration with the server to lock
+  down profile, entrypoints, and other attributes that will not change on 
+  a frame-by-frame basis.
+- Create a decode context which represents a "virtualized" hardware decode 
+  device
+- Get and fill decode buffers with picture level, slice level and macroblock 
+  level data (depending on entrypoints)
+- Pass the decode buffers to the server to decode the current frame
+
+Initialization & Configuration Management 
+
+- Find out supported profiles
+- Find out entrypoints for a given profile
+- Find out configuration attributes for a given profile/entrypoint pair
+- Create a configuration for use by the decoder
+
+*/
+
+typedef void* VADisplay;	/* window system dependent */
+
+typedef int VAStatus;	/** Return status type from functions */
+/** Values for the return status */
+#define VA_STATUS_SUCCESS			0x00000000
+#define VA_STATUS_ERROR_OPERATION_FAILED	0x00000001
+#define VA_STATUS_ERROR_ALLOCATION_FAILED	0x00000002
+#define VA_STATUS_ERROR_INVALID_DISPLAY		0x00000003
+#define VA_STATUS_ERROR_INVALID_CONFIG		0x00000004
+#define VA_STATUS_ERROR_INVALID_CONTEXT		0x00000005
+#define VA_STATUS_ERROR_INVALID_SURFACE		0x00000006
+#define VA_STATUS_ERROR_INVALID_BUFFER		0x00000007
+#define VA_STATUS_ERROR_INVALID_IMAGE		0x00000008
+#define VA_STATUS_ERROR_INVALID_SUBPICTURE	0x00000009
+#define VA_STATUS_ERROR_ATTR_NOT_SUPPORTED	0x0000000a
+#define VA_STATUS_ERROR_MAX_NUM_EXCEEDED	0x0000000b
+#define VA_STATUS_ERROR_UNSUPPORTED_PROFILE	0x0000000c
+#define VA_STATUS_ERROR_UNSUPPORTED_ENTRYPOINT	0x0000000d
+#define VA_STATUS_ERROR_UNSUPPORTED_RT_FORMAT	0x0000000e
+#define VA_STATUS_ERROR_UNSUPPORTED_BUFFERTYPE	0x0000000f
+#define VA_STATUS_ERROR_SURFACE_BUSY		0x00000010
+#define VA_STATUS_ERROR_FLAG_NOT_SUPPORTED      0x00000011
+#define VA_STATUS_ERROR_INVALID_PARAMETER	0x00000012
+#define VA_STATUS_ERROR_RESOLUTION_NOT_SUPPORTED 0x00000013
+#define VA_STATUS_ERROR_UNIMPLEMENTED           0x00000014
+#define VA_STATUS_ERROR_SURFACE_IN_DISPLAYING   0x00000015
+#define VA_STATUS_ERROR_INVALID_IMAGE_FORMAT    0x00000016
+#define VA_STATUS_ERROR_DECODING_ERROR          0x00000017
+#define VA_STATUS_ERROR_ENCODING_ERROR          0x00000018
+/**
+ * \brief An invalid/unsupported value was supplied.
+ *
+ * This is a catch-all error code for invalid or unsupported values.
+ * e.g. value exceeding the valid range, invalid type in the context
+ * of generic attribute values.
+ */
+#define VA_STATUS_ERROR_INVALID_VALUE           0x00000019
+/** \brief An unsupported filter was supplied. */
+#define VA_STATUS_ERROR_UNSUPPORTED_FILTER      0x00000020
+/** \brief An invalid filter chain was supplied. */
+#define VA_STATUS_ERROR_INVALID_FILTER_CHAIN    0x00000021
+/** \brief Indicate HW busy (e.g. run multiple encoding simultaneously). */
+#define VA_STATUS_ERROR_HW_BUSY	                0x00000022
+/** \brief An unsupported memory type was supplied. */
+#define VA_STATUS_ERROR_UNSUPPORTED_MEMORY_TYPE 0x00000024
+#define VA_STATUS_ERROR_UNKNOWN			0xFFFFFFFF
+
+/** De-interlacing flags for vaPutSurface() */
+#define VA_FRAME_PICTURE        0x00000000 
+#define VA_TOP_FIELD            0x00000001
+#define VA_BOTTOM_FIELD         0x00000002
+
+/**
+ * Enabled the positioning/cropping/blending feature:
+ * 1, specify the video playback position in the isurface
+ * 2, specify the cropping info for video playback
+ * 3, encoded video will blend with background color
+ */
+#define VA_ENABLE_BLEND         0x00000004 /* video area blend with the constant color */ 
+    
+/**
+ * Clears the drawable with background color.
+ * for hardware overlay based implementation this flag
+ * can be used to turn off the overlay
+ */
+#define VA_CLEAR_DRAWABLE       0x00000008
+
+/** Color space conversion flags for vaPutSurface() */
+#define VA_SRC_COLOR_MASK       0x000000f0
+#define VA_SRC_BT601            0x00000010
+#define VA_SRC_BT709            0x00000020
+#define VA_SRC_SMPTE_240        0x00000040
+
+/** Scaling flags for vaPutSurface() */
+#define VA_FILTER_SCALING_DEFAULT       0x00000000
+#define VA_FILTER_SCALING_FAST          0x00000100
+#define VA_FILTER_SCALING_HQ            0x00000200
+#define VA_FILTER_SCALING_NL_ANAMORPHIC 0x00000300
+#define VA_FILTER_SCALING_MASK          0x00000f00
+
+/**
+ * Returns a short english description of error_status
+ */
+const char *vaErrorStr(VAStatus error_status);
+
+/**
+ * Initialization:
+ * A display must be obtained by calling vaGetDisplay() before calling
+ * vaInitialize() and other functions. This connects the API to the 
+ * native window system.
+ * For X Windows, native_dpy would be from XOpenDisplay()
+ */
+typedef void* VANativeDisplay;	/* window system dependent */
+
+int vaDisplayIsValid(VADisplay dpy);
+
+/**
+ *  Set the override driver name instead of queried driver driver.
+ */
+VAStatus vaSetDriverName(VADisplay dpy,
+                         char *driver_name
+);
+
+/**
+ * Initialize the library 
+ */
+VAStatus vaInitialize (
+    VADisplay dpy,
+    int *major_version,	 /* out */
+    int *minor_version 	 /* out */
+);
+
+/**
+ * After this call, all library internal resources will be cleaned up
+ */ 
+VAStatus vaTerminate (
+    VADisplay dpy
+);
+
+/**
+ * vaQueryVendorString returns a pointer to a zero-terminated string
+ * describing some aspects of the VA implemenation on a specific    
+ * hardware accelerator. The format of the returned string is vendor
+ * specific and at the discretion of the implementer.
+ * e.g. for the Intel GMA500 implementation, an example would be:
+ * "Intel GMA500 - 2.0.0.32L.0005"
+ */
+const char *vaQueryVendorString (
+    VADisplay dpy
+);
+
+typedef int (*VAPrivFunc)();
+
+/**
+ * Return a function pointer given a function name in the library.
+ * This allows private interfaces into the library
+ */ 
+VAPrivFunc vaGetLibFunc (
+    VADisplay dpy,
+    const char *func
+);
+
+/** Currently defined profiles */
+typedef enum
+{
+    /** \brief Profile ID used for video processing. */
+    VAProfileNone                       = -1,
+    VAProfileMPEG2Simple		= 0,
+    VAProfileMPEG2Main			= 1,
+    VAProfileMPEG4Simple		= 2,
+    VAProfileMPEG4AdvancedSimple	= 3,
+    VAProfileMPEG4Main			= 4,
+    VAProfileH264Baseline		= 5,
+    VAProfileH264Main			= 6,
+    VAProfileH264High			= 7,
+    VAProfileVC1Simple			= 8,
+    VAProfileVC1Main			= 9,
+    VAProfileVC1Advanced		= 10,
+    VAProfileH263Baseline		= 11,
+    VAProfileJPEGBaseline               = 12,
+    VAProfileH264ConstrainedBaseline    = 13,
+    VAProfileVP8Version0_3              = 14,
+    VAProfileH264MultiviewHigh          = 15,
+    VAProfileH264StereoHigh             = 16,
+    VAProfileHEVCMain                   = 17,
+    VAProfileHEVCMain10                 = 18,
+    VAProfileVP9Profile0                = 19
+} VAProfile;
+
+/**
+ *  Currently defined entrypoints 
+ */
+typedef enum
+{
+    VAEntrypointVLD		= 1,
+    VAEntrypointIZZ		= 2,
+    VAEntrypointIDCT		= 3,
+    VAEntrypointMoComp		= 4,
+    VAEntrypointDeblocking	= 5,
+    VAEntrypointEncSlice	= 6,	/* slice level encode */
+    VAEntrypointEncPicture 	= 7,	/* pictuer encode, JPEG, etc */
+    VAEntrypointVideoProc       = 10,   /**< Video pre/post-processing. */
+} VAEntrypoint;
+
+/** Currently defined configuration attribute types */
+typedef enum
+{
+    VAConfigAttribRTFormat		= 0,
+    VAConfigAttribSpatialResidual	= 1,
+    VAConfigAttribSpatialClipping	= 2,
+    VAConfigAttribIntraResidual		= 3,
+    VAConfigAttribEncryption		= 4,
+    VAConfigAttribRateControl		= 5,
+
+    /** @name Attributes for decoding */
+    /**@{*/
+    /**
+     * \brief Slice Decoding mode. Read/write.
+     *
+     * This attribute determines what mode the driver supports for slice
+     * decoding, through vaGetConfigAttributes(); and what mode the user
+     * will be providing to the driver, through vaCreateConfig(), if the
+     * driver supports those. If this attribute is not set by the user then
+     * it is assumed that VA_DEC_SLICE_MODE_NORMAL mode is used.
+     *
+     * See \c VA_DEC_SLICE_MODE_xxx for the list of slice decoding modes.
+     */
+    VAConfigAttribDecSliceMode		= 6,
+
+    /** @name Attributes for encoding */
+    /**@{*/
+    /**
+     * \brief Packed headers mode. Read/write.
+     *
+     * This attribute determines what packed headers the driver supports,
+     * through vaGetConfigAttributes(); and what packed headers the user
+     * will be providing to the driver, through vaCreateConfig(), if the
+     * driver supports those.
+     *
+     * See \c VA_ENC_PACKED_HEADER_xxx for the list of packed headers.
+     */
+    VAConfigAttribEncPackedHeaders      = 10,
+    /**
+     * \brief Interlaced mode. Read/write.
+     *
+     * This attribute determines what kind of interlaced encoding mode
+     * the driver supports.
+     *
+     * See \c VA_ENC_INTERLACED_xxx for the list of interlaced modes.
+     */
+    VAConfigAttribEncInterlaced         = 11,
+    /**
+     * \brief Maximum number of reference frames. Read-only.
+     *
+     * This attribute determines the maximum number of reference
+     * frames supported for encoding.
+     *
+     * Note: for H.264 encoding, the value represents the maximum number
+     * of reference frames for both the reference picture list 0 (bottom
+     * 16 bits) and the reference picture list 1 (top 16 bits).
+     */
+    VAConfigAttribEncMaxRefFrames       = 13,
+    /**
+     * \brief Maximum number of slices per frame. Read-only.
+     *
+     * This attribute determines the maximum number of slices the
+     * driver can support to encode a single frame.
+     */
+    VAConfigAttribEncMaxSlices          = 14,
+    /**
+     * \brief Slice structure. Read-only.
+     *
+     * This attribute determines slice structures supported by the
+     * driver for encoding. This attribute is a hint to the user so
+     * that he can choose a suitable surface size and how to arrange
+     * the encoding process of multiple slices per frame.
+     *
+     * More specifically, for H.264 encoding, this attribute
+     * determines the range of accepted values to
+     * VAEncSliceParameterBufferH264::macroblock_address and
+     * VAEncSliceParameterBufferH264::num_macroblocks.
+     *
+     * See \c VA_ENC_SLICE_STRUCTURE_xxx for the supported slice
+     * structure types.
+     */
+    VAConfigAttribEncSliceStructure     = 15,
+    /**
+     * \brief Macroblock information. Read-only.
+     *
+     * This attribute determines whether the driver supports extra
+     * encoding information per-macroblock. e.g. QP.
+     *
+     * More specifically, for H.264 encoding, if the driver returns a non-zero
+     * value for this attribute, this means the application can create
+     * additional #VAEncMacroblockParameterBufferH264 buffers referenced
+     * through VAEncSliceParameterBufferH264::macroblock_info.
+     */
+    VAConfigAttribEncMacroblockInfo     = 16,
+    /**
+     * \brief JPEG encoding attribute. Read-only.
+     *
+     * This attribute exposes a number of capabilities of the underlying
+     * JPEG implementation. The attribute value is partitioned into fields as defined in the 
+     * VAConfigAttribValEncJPEG union.
+     */
+    VAConfigAttribEncJPEG             = 20,
+    /**
+     * \brief Encoding quality range attribute. Read-only.
+     *
+     * This attribute conveys whether the driver supports different quality level settings
+     * for encoding. A value less than or equal to 1 means that the encoder only has a single
+     * quality setting, and a value greater than 1 represents the number of quality levels 
+     * that can be configured. e.g. a value of 2 means there are two distinct quality levels. 
+     */
+    VAConfigAttribEncQualityRange     = 21,
+    /**
+     * \brief Encoding skip frame attribute. Read-only.
+     *
+     * This attribute conveys whether the driver supports sending skip frame parameters 
+     * (VAEncMiscParameterTypeSkipFrame) to the encoder's rate control, when the user has 
+     * externally skipped frames. 
+     */
+    VAConfigAttribEncSkipFrame        = 24,
+    /**@}*/
+    VAConfigAttribTypeMax
+} VAConfigAttribType;
+
+/**
+ * Configuration attributes
+ * If there is more than one value for an attribute, a default
+ * value will be assigned to the attribute if the client does not
+ * specify the attribute when creating a configuration
+ */
+typedef struct _VAConfigAttrib {
+    VAConfigAttribType type;
+    unsigned int value; /* OR'd flags (bits) for this attribute */
+} VAConfigAttrib;
+
+/** attribute value for VAConfigAttribRTFormat */
+#define VA_RT_FORMAT_YUV420	0x00000001	
+#define VA_RT_FORMAT_YUV422	0x00000002
+#define VA_RT_FORMAT_YUV444	0x00000004
+#define VA_RT_FORMAT_YUV411	0x00000008
+#define VA_RT_FORMAT_YUV400	0x00000010
+#define VA_RT_FORMAT_RGB16	0x00010000
+#define VA_RT_FORMAT_RGB32	0x00020000
+/* RGBP covers RGBP and BGRP fourcc */ 
+#define VA_RT_FORMAT_RGBP	0x00100000
+#define VA_RT_FORMAT_PROTECTED	0x80000000
+
+/** @name Attribute values for VAConfigAttribRateControl */
+/**@{*/
+/** \brief Driver does not support any form of rate control. */
+#define VA_RC_NONE                      0x00000001
+/** \brief Constant bitrate. */
+#define VA_RC_CBR                       0x00000002
+/** \brief Variable bitrate. */
+#define VA_RC_VBR                       0x00000004
+/** \brief Video conference mode. */
+#define VA_RC_VCM                       0x00000008
+/** \brief Constant QP. */
+#define VA_RC_CQP                       0x00000010
+/** \brief Variable bitrate with peak rate higher than average bitrate. */
+#define VA_RC_VBR_CONSTRAINED           0x00000020
+/**@}*/
+
+/** @name Attribute values for VAConfigAttribDecSliceMode */
+/**@{*/
+/** \brief Driver supports normal mode for slice decoding */
+#define VA_DEC_SLICE_MODE_NORMAL       0x00000001
+/** \brief Driver supports base mode for slice decoding */
+#define VA_DEC_SLICE_MODE_BASE         0x00000002
+/**@}*/
+
+/** @name Attribute values for VAConfigAttribEncPackedHeaders */
+/**@{*/
+/** \brief Driver does not support any packed headers mode. */
+#define VA_ENC_PACKED_HEADER_NONE       0x00000000
+/** \brief Driver supports packed sequence headers. e.g. SPS for H.264. */
+#define VA_ENC_PACKED_HEADER_SEQUENCE   0x00000001
+/** \brief Driver supports packed picture headers. e.g. PPS for H.264. */
+#define VA_ENC_PACKED_HEADER_PICTURE    0x00000002
+/** \brief Driver supports packed slice headers. e.g. \c slice_header() for H.264. */
+#define VA_ENC_PACKED_HEADER_SLICE      0x00000004
+/** \brief Driver supports misc packed headers. e.g. SEI for H.264. */
+#define VA_ENC_PACKED_HEADER_MISC       0x00000008
+/** \brief Driver supports raw packed header, see VAEncPackedHeaderRawData */
+#define VA_ENC_PACKED_HEADER_RAW_DATA   0x00000010
+/**@}*/
+
+/** @name Attribute values for VAConfigAttribEncInterlaced */
+/**@{*/
+/** \brief Driver does not support interlaced coding. */
+#define VA_ENC_INTERLACED_NONE          0x00000000
+/** \brief Driver supports interlaced frame coding. */
+#define VA_ENC_INTERLACED_FRAME         0x00000001
+/** \brief Driver supports interlaced field coding. */
+#define VA_ENC_INTERLACED_FIELD         0x00000002
+/** \brief Driver supports macroblock adaptive frame field coding. */
+#define VA_ENC_INTERLACED_MBAFF         0x00000004
+/** \brief Driver supports picture adaptive frame field coding. */
+#define VA_ENC_INTERLACED_PAFF          0x00000008
+/**@}*/
+
+/** @name Attribute values for VAConfigAttribEncSliceStructure */
+/**@{*/
+/** \brief Driver supports an arbitrary number of rows per slice. */
+#define VA_ENC_SLICE_STRUCTURE_ARBITRARY_ROWS           0x00000000
+/** \brief Driver supports a power-of-two number of rows per slice. */
+#define VA_ENC_SLICE_STRUCTURE_POWER_OF_TWO_ROWS        0x00000001
+/** \brief Driver supports an arbitrary number of rows per slice. */
+#define VA_ENC_SLICE_STRUCTURE_ARBITRARY_MACROBLOCKS    0x00000002
+/**@}*/
+
+/** \brief Attribute value for VAConfigAttribEncJPEG */
+typedef union _VAConfigAttribValEncJPEG {
+    struct {
+        /** \brief set to 1 for arithmatic coding. */
+        unsigned int arithmatic_coding_mode : 1;
+        /** \brief set to 1 for progressive dct. */
+        unsigned int progressive_dct_mode : 1;
+        /** \brief set to 1 for non-interleaved. */
+        unsigned int non_interleaved_mode : 1;
+        /** \brief set to 1 for differential. */
+        unsigned int differential_mode : 1;
+        unsigned int max_num_components : 3;
+        unsigned int max_num_scans : 4;
+        unsigned int max_num_huffman_tables : 3;
+        unsigned int max_num_quantization_tables : 3;
+    } bits;
+    unsigned int value;
+} VAConfigAttribValEncJPEG;
+
+/**
+ * if an attribute is not applicable for a given
+ * profile/entrypoint pair, then set the value to the following 
+ */
+#define VA_ATTRIB_NOT_SUPPORTED 0x80000000
+
+/** Get maximum number of profiles supported by the implementation */
+int vaMaxNumProfiles (
+    VADisplay dpy
+);
+
+/** Get maximum number of entrypoints supported by the implementation */
+int vaMaxNumEntrypoints (
+    VADisplay dpy
+);
+
+/** Get maximum number of attributs supported by the implementation */
+int vaMaxNumConfigAttributes (
+    VADisplay dpy
+);
+
+/**
+ * Query supported profiles 
+ * The caller must provide a "profile_list" array that can hold at
+ * least vaMaxNumProfile() entries. The actual number of profiles
+ * returned in "profile_list" is returned in "num_profile".
+ */
+VAStatus vaQueryConfigProfiles (
+    VADisplay dpy,
+    VAProfile *profile_list,	/* out */
+    int *num_profiles		/* out */
+);
+
+/**
+ * Query supported entrypoints for a given profile 
+ * The caller must provide an "entrypoint_list" array that can hold at
+ * least vaMaxNumEntrypoints() entries. The actual number of entrypoints 
+ * returned in "entrypoint_list" is returned in "num_entrypoints".
+ */
+VAStatus vaQueryConfigEntrypoints (
+    VADisplay dpy,
+    VAProfile profile,
+    VAEntrypoint *entrypoint_list,	/* out */
+    int *num_entrypoints		/* out */
+);
+
+/**
+ * Get attributes for a given profile/entrypoint pair 
+ * The caller must provide an "attrib_list" with all attributes to be 
+ * retrieved.  Upon return, the attributes in "attrib_list" have been 
+ * updated with their value.  Unknown attributes or attributes that are 
+ * not supported for the given profile/entrypoint pair will have their 
+ * value set to VA_ATTRIB_NOT_SUPPORTED
+ */
+VAStatus vaGetConfigAttributes (
+    VADisplay dpy,
+    VAProfile profile,
+    VAEntrypoint entrypoint,
+    VAConfigAttrib *attrib_list, /* in/out */
+    int num_attribs
+);
+
+/** Generic ID type, can be re-typed for specific implementation */
+typedef unsigned int VAGenericID;
+
+typedef VAGenericID VAConfigID;
+
+/**
+ * Create a configuration for the decode pipeline 
+ * it passes in the attribute list that specifies the attributes it cares 
+ * about, with the rest taking default values.  
+ */
+VAStatus vaCreateConfig (
+    VADisplay dpy,
+    VAProfile profile, 
+    VAEntrypoint entrypoint, 
+    VAConfigAttrib *attrib_list,
+    int num_attribs,
+    VAConfigID *config_id /* out */
+);
+
+/**
+ * Free resources associdated with a given config 
+ */
+VAStatus vaDestroyConfig (
+    VADisplay dpy,
+    VAConfigID config_id
+);
+
+/**
+ * Query all attributes for a given configuration 
+ * The profile of the configuration is returned in "profile"
+ * The entrypoint of the configuration is returned in "entrypoint"
+ * The caller must provide an "attrib_list" array that can hold at least 
+ * vaMaxNumConfigAttributes() entries. The actual number of attributes 
+ * returned in "attrib_list" is returned in "num_attribs"
+ */
+VAStatus vaQueryConfigAttributes (
+    VADisplay dpy,
+    VAConfigID config_id, 
+    VAProfile *profile, 	/* out */
+    VAEntrypoint *entrypoint, 	/* out */
+    VAConfigAttrib *attrib_list,/* out */
+    int *num_attribs 		/* out */
+);
+
+
+/**
+ * Contexts and Surfaces
+ *
+ * Context represents a "virtual" video decode pipeline. Surfaces are render 
+ * targets for a given context. The data in the surfaces are not accessible  
+ * to the client and the internal data format of the surface is implementatin 
+ * specific. 
+ *
+ * Surfaces will be bound to a context when the context is created. Once
+ * a surface is bound to a given context, it can not be used to create  
+ * another context. The association is removed when the context is destroyed
+ * 
+ * Both contexts and surfaces are identified by unique IDs and its
+ * implementation specific internals are kept opaque to the clients
+ */
+
+typedef VAGenericID VAContextID;
+
+typedef VAGenericID VASurfaceID;
+
+#define VA_INVALID_ID		0xffffffff
+#define VA_INVALID_SURFACE	VA_INVALID_ID
+
+/** \brief Generic value types. */
+typedef enum  {
+    VAGenericValueTypeInteger = 1,      /**< 32-bit signed integer. */
+    VAGenericValueTypeFloat,            /**< 32-bit floating-point value. */
+    VAGenericValueTypePointer,          /**< Generic pointer type */
+    VAGenericValueTypeFunc              /**< Pointer to function */
+} VAGenericValueType;
+
+/** \brief Generic function type. */
+typedef void (*VAGenericFunc)(void);
+
+/** \brief Generic value. */
+typedef struct _VAGenericValue {
+    /** \brief Value type. See #VAGenericValueType. */
+    VAGenericValueType  type;
+    /** \brief Value holder. */
+    union {
+        /** \brief 32-bit signed integer. */
+        int             i;
+        /** \brief 32-bit float. */
+        float           f;
+        /** \brief Generic pointer. */
+        void           *p;
+        /** \brief Pointer to function. */
+        VAGenericFunc   fn;
+    }                   value;
+} VAGenericValue;
+
+/** @name Surface attribute flags */
+/**@{*/
+/** \brief Surface attribute is not supported. */
+#define VA_SURFACE_ATTRIB_NOT_SUPPORTED 0x00000000
+/** \brief Surface attribute can be got through vaQuerySurfaceAttributes(). */
+#define VA_SURFACE_ATTRIB_GETTABLE      0x00000001
+/** \brief Surface attribute can be set through vaCreateSurfaces(). */
+#define VA_SURFACE_ATTRIB_SETTABLE      0x00000002
+/**@}*/
+
+/** \brief Surface attribute types. */
+typedef enum {
+    VASurfaceAttribNone = 0,
+    /**
+     * \brief Pixel format (fourcc).
+     *
+     * The value is meaningful as input to vaQuerySurfaceAttributes().
+     * If zero, the driver returns the optimal pixel format for the
+     * specified config. Otherwise, if non-zero, the value represents
+     * a pixel format (FOURCC) that is kept as is on output, if the
+     * driver supports it. Otherwise, the driver sets the value to
+     * zero and drops the \c VA_SURFACE_ATTRIB_SETTABLE flag.
+     */
+    VASurfaceAttribPixelFormat,
+    /** \brief Minimal width in pixels (int, read-only). */
+    VASurfaceAttribMinWidth,
+    /** \brief Maximal width in pixels (int, read-only). */
+    VASurfaceAttribMaxWidth,
+    /** \brief Minimal height in pixels (int, read-only). */
+    VASurfaceAttribMinHeight,
+    /** \brief Maximal height in pixels (int, read-only). */
+    VASurfaceAttribMaxHeight,
+    /** \brief Surface memory type expressed in bit fields (int, read/write). */
+    VASurfaceAttribMemoryType,
+    /** \brief External buffer descriptor (pointer, write). */
+    VASurfaceAttribExternalBufferDescriptor,
+    /** \brief Surface usage hint, gives the driver a hint of intended usage 
+     *  to optimize allocation (e.g. tiling) (int, read/write). */
+    VASurfaceAttribUsageHint,
+    /** \brief Number of surface attributes. */
+    VASurfaceAttribCount
+} VASurfaceAttribType;
+
+/** \brief Surface attribute. */
+typedef struct _VASurfaceAttrib {
+    /** \brief Type. */
+    VASurfaceAttribType type;
+    /** \brief Flags. See "Surface attribute flags". */
+    unsigned int        flags;
+    /** \brief Value. See "Surface attribute types" for the expected types. */
+    VAGenericValue      value;
+} VASurfaceAttrib;
+
+/** 
+ * @name VASurfaceAttribMemoryType values in bit fields. 
+ * Bit 0:7 are reserved for generic types, Bit 31:28 are reserved for 
+ * Linux DRM, Bit 23:20 are reserved for Android. DRM and Android specific
+ * types are defined in DRM and Android header files.
+ */
+/**@{*/
+/** \brief VA memory type (default) is supported. */
+#define VA_SURFACE_ATTRIB_MEM_TYPE_VA			0x00000001
+/** \brief V4L2 buffer memory type is supported. */
+#define VA_SURFACE_ATTRIB_MEM_TYPE_V4L2			0x00000002
+/** \brief User pointer memory type is supported. */
+#define VA_SURFACE_ATTRIB_MEM_TYPE_USER_PTR		0x00000004
+/**@}*/
+
+/** 
+ * \brief VASurfaceAttribExternalBuffers structure for 
+ * the VASurfaceAttribExternalBufferDescriptor attribute.
+ */
+typedef struct _VASurfaceAttribExternalBuffers {
+    /** \brief pixel format in fourcc. */
+    unsigned int pixel_format;
+    /** \brief width in pixels. */
+    unsigned int width;
+    /** \brief height in pixels. */
+    unsigned int height;
+    /** \brief total size of the buffer in bytes. */
+    unsigned int data_size;
+    /** \brief number of planes for planar layout */
+    unsigned int num_planes;
+    /** \brief pitch for each plane in bytes */
+    unsigned int pitches[4];
+    /** \brief offset for each plane in bytes */
+    unsigned int offsets[4];
+    /** \brief buffer handles or user pointers */
+    unsigned long *buffers;
+    /** \brief number of elements in the "buffers" array */
+    unsigned int num_buffers;
+    /** \brief flags. See "Surface external buffer descriptor flags". */
+    unsigned int flags;
+    /** \brief reserved for passing private data */
+    void *private_data;
+} VASurfaceAttribExternalBuffers;
+
+/** @name VASurfaceAttribExternalBuffers flags */
+/**@{*/
+/** \brief Enable memory tiling */
+#define VA_SURFACE_EXTBUF_DESC_ENABLE_TILING	0x00000001
+/** \brief Memory is cacheable */
+#define VA_SURFACE_EXTBUF_DESC_CACHED		0x00000002
+/** \brief Memory is non-cacheable */
+#define VA_SURFACE_EXTBUF_DESC_UNCACHED		0x00000004
+/** \brief Memory is write-combined */
+#define VA_SURFACE_EXTBUF_DESC_WC		0x00000008
+/** \brief Memory is protected */
+#define VA_SURFACE_EXTBUF_DESC_PROTECTED        0x80000000
+
+/** @name VASurfaceAttribUsageHint attribute usage hint flags */
+/**@{*/
+/** \brief Surface usage not indicated. */
+#define VA_SURFACE_ATTRIB_USAGE_HINT_GENERIC 	0x00000000
+/** \brief Surface used by video decoder. */
+#define VA_SURFACE_ATTRIB_USAGE_HINT_DECODER 	0x00000001
+/** \brief Surface used by video encoder. */
+#define VA_SURFACE_ATTRIB_USAGE_HINT_ENCODER 	0x00000002
+/** \brief Surface read by video post-processing. */
+#define VA_SURFACE_ATTRIB_USAGE_HINT_VPP_READ 	0x00000004
+/** \brief Surface written by video post-processing. */
+#define VA_SURFACE_ATTRIB_USAGE_HINT_VPP_WRITE 	0x00000008
+/** \brief Surface used for display. */
+#define VA_SURFACE_ATTRIB_USAGE_HINT_DISPLAY 	0x00000010
+
+/**@}*/
+
+/**
+ * \brief Queries surface attributes for the supplied config.
+ *
+ * Unlike vaGetSurfaceAttributes(), this function queries for all
+ * supported attributes for the supplied VA @config. In particular, if
+ * the underlying hardware supports the creation of VA surfaces in
+ * various formats, then this function will enumerate all pixel
+ * formats that are supported.
+ *
+ * The \c attrib_list array is allocated by the user and \c
+ * num_attribs shall be initialized to the number of allocated
+ * elements in that array. Upon successful return, the actual number
+ * of attributes will be overwritten into \c num_attribs. Otherwise,
+ * \c VA_STATUS_ERROR_MAX_NUM_EXCEEDED is returned and \c num_attribs
+ * is adjusted to the number of elements that would be returned if
+ * enough space was available.
+ *
+ * Note: it is perfectly valid to pass NULL to the \c attrib_list
+ * argument when vaQuerySurfaceAttributes() is used to determine the
+ * actual number of elements that need to be allocated.
+ *
+ * @param[in] dpy               the VA display
+ * @param[in] config            the config identifying a codec or a video
+ *     processing pipeline
+ * @param[out] attrib_list      the output array of #VASurfaceAttrib elements
+ * @param[in,out] num_attribs   the number of elements allocated on
+ *      input, the number of elements actually filled in output
+ */
+VAStatus
+vaQuerySurfaceAttributes(
+    VADisplay           dpy,
+    VAConfigID          config,
+    VASurfaceAttrib    *attrib_list,
+    unsigned int       *num_attribs
+);
+
+/**
+ * \brief Creates an array of surfaces
+ *
+ * Creates an array of surfaces. The optional list of attributes shall
+ * be constructed and validated through vaGetSurfaceAttributes() or
+ * constructed based based on what the underlying hardware could
+ * expose through vaQuerySurfaceAttributes().
+ *
+ * @param[in] dpy               the VA display
+ * @param[in] format            the desired surface format. See \c VA_RT_FORMAT_*
+ * @param[in] width             the surface width
+ * @param[in] height            the surface height
+ * @param[out] surfaces         the array of newly created surfaces
+ * @param[in] num_surfaces      the number of surfaces to create
+ * @param[in] attrib_list       the list of (optional) attributes, or \c NULL
+ * @param[in] num_attribs       the number of attributes supplied in
+ *     \c attrib_list, or zero
+ */
+VAStatus
+vaCreateSurfaces(
+    VADisplay           dpy,
+    unsigned int        format,
+    unsigned int        width,
+    unsigned int        height,
+    VASurfaceID        *surfaces,
+    unsigned int        num_surfaces,
+    VASurfaceAttrib    *attrib_list,
+    unsigned int        num_attribs
+);
+    
+/**
+ * vaDestroySurfaces - Destroy resources associated with surfaces. 
+ *  Surfaces can only be destroyed after the context associated has been 
+ *  destroyed.  
+ *  dpy: display
+ *  surfaces: array of surfaces to destroy
+ *  num_surfaces: number of surfaces in the array to be destroyed.
+ */
+VAStatus vaDestroySurfaces (
+    VADisplay dpy,
+    VASurfaceID *surfaces,
+    int num_surfaces
+);
+
+#define VA_PROGRESSIVE 0x1
+/**
+ * vaCreateContext - Create a context
+ *  dpy: display
+ *  config_id: configuration for the context
+ *  picture_width: coded picture width
+ *  picture_height: coded picture height
+ *  flag: any combination of the following:
+ *    VA_PROGRESSIVE (only progressive frame pictures in the sequence when set)
+ *  render_targets: render targets (surfaces) tied to the context
+ *  num_render_targets: number of render targets in the above array
+ *  context: created context id upon return
+ */
+VAStatus vaCreateContext (
+    VADisplay dpy,
+    VAConfigID config_id,
+    int picture_width,
+    int picture_height,
+    int flag,
+    VASurfaceID *render_targets,
+    int num_render_targets,
+    VAContextID *context		/* out */
+);
+
+/**
+ * vaDestroyContext - Destroy a context 
+ *  dpy: display
+ *  context: context to be destroyed
+ */
+VAStatus vaDestroyContext (
+    VADisplay dpy,
+    VAContextID context
+);
+
+/**
+ * Buffers 
+ * Buffers are used to pass various types of data from the
+ * client to the server. The server maintains a data store
+ * for each buffer created, and the client idenfies a buffer
+ * through a unique buffer id assigned by the server.
+ */
+
+typedef VAGenericID VABufferID;
+
+typedef enum
+{
+    VAPictureParameterBufferType	= 0,
+    VAIQMatrixBufferType		= 1,
+    VABitPlaneBufferType		= 2,
+    VASliceGroupMapBufferType		= 3,
+    VASliceParameterBufferType		= 4,
+    VASliceDataBufferType		= 5,
+    VAMacroblockParameterBufferType	= 6,
+    VAResidualDataBufferType		= 7,
+    VADeblockingParameterBufferType	= 8,
+    VAImageBufferType			= 9,
+    VAProtectedSliceDataBufferType	= 10,
+    VAQMatrixBufferType                 = 11,
+    VAHuffmanTableBufferType            = 12,
+    VAProbabilityBufferType             = 13,
+
+/* Following are encode buffer types */
+    VAEncCodedBufferType		= 21,
+    VAEncSequenceParameterBufferType	= 22,
+    VAEncPictureParameterBufferType	= 23,
+    VAEncSliceParameterBufferType	= 24,
+    VAEncPackedHeaderParameterBufferType = 25,
+    VAEncPackedHeaderDataBufferType     = 26,
+    VAEncMiscParameterBufferType	= 27,
+    VAEncMacroblockParameterBufferType	= 28,
+    VAEncMacroblockMapBufferType        = 29,
+/* Following are video processing buffer types */
+    /**
+     * \brief Video processing pipeline parameter buffer.
+     *
+     * This buffer describes the video processing pipeline. See
+     * #VAProcPipelineParameterBuffer for details.
+     */
+    VAProcPipelineParameterBufferType   = 41,
+    /**
+     * \brief Video filter parameter buffer.
+     *
+     * This buffer describes the video filter parameters. All buffers
+     * inherit from #VAProcFilterParameterBufferBase, thus including
+     * a unique filter buffer type.
+     *
+     * The default buffer used by most filters is #VAProcFilterParameterBuffer.
+     * Filters requiring advanced parameters include, but are not limited to,
+     * deinterlacing (#VAProcFilterParameterBufferDeinterlacing),
+     * color balance (#VAProcFilterParameterBufferColorBalance), etc.
+     */
+    VAProcFilterParameterBufferType     = 42,
+    VABufferTypeMax
+} VABufferType;
+
+typedef enum
+{
+    VAEncMiscParameterTypeFrameRate 	= 0,
+    VAEncMiscParameterTypeRateControl  	= 1,
+    VAEncMiscParameterTypeMaxSliceSize	= 2,
+    VAEncMiscParameterTypeAIR    	= 3,
+    /** \brief Buffer type used to express a maximum frame size (in bits). */
+    VAEncMiscParameterTypeMaxFrameSize  = 4,
+    /** \brief Buffer type used for HRD parameters. */
+    VAEncMiscParameterTypeHRD           = 5,
+    VAEncMiscParameterTypeQualityLevel  = 6,
+    /** \brief Buffer type used for sending skip frame parameters to the encoder's
+      * rate control, when the user has externally skipped frames. */
+    VAEncMiscParameterTypeSkipFrame     = 9
+} VAEncMiscParameterType;
+
+/** \brief Packed header type. */
+typedef enum {
+    /** \brief Packed sequence header. */
+    VAEncPackedHeaderSequence   = 1,
+    /** \brief Packed picture header. */
+    VAEncPackedHeaderPicture    = 2,
+    /** \brief Packed slice header. */
+    VAEncPackedHeaderSlice      = 3,
+    /** 
+     * \brief Packed raw header. 
+     * 
+     * Packed raw data header can be used by the client to insert a header  
+     * into the bitstream data buffer at the point it is passed, the driver 
+     * will handle the raw packed header based on "has_emulation_bytes" field
+     * in the packed header parameter structure.
+     */
+    VAEncPackedHeaderRawData    = 4,
+    /** \brief Misc packed header. See codec-specific definitions. */
+    VAEncPackedHeaderMiscMask   = 0x80000000,
+} VAEncPackedHeaderType;
+
+/** \brief Packed header parameter. */
+typedef struct _VAEncPackedHeaderParameterBuffer {
+    /** Type of the packed header buffer. See #VAEncPackedHeaderType. */
+    unsigned int                type;
+    /** \brief Size of the #VAEncPackedHeaderDataBuffer in bits. */
+    unsigned int                bit_length;
+    /** \brief Flag: buffer contains start code emulation prevention bytes? */
+    unsigned char               has_emulation_bytes;
+} VAEncPackedHeaderParameterBuffer;
+
+/**
+ *  For application, e.g. set a new bitrate
+ *    VABufferID buf_id;
+ *    VAEncMiscParameterBuffer *misc_param;
+ *    VAEncMiscParameterRateControl *misc_rate_ctrl;
+ * 
+ *    vaCreateBuffer(dpy, context, VAEncMiscParameterBufferType,
+ *              sizeof(VAEncMiscParameterBuffer) + sizeof(VAEncMiscParameterRateControl),
+ *              1, NULL, &buf_id);
+ *
+ *    vaMapBuffer(dpy,buf_id,(void **)&misc_param);
+ *    misc_param->type = VAEncMiscParameterTypeRateControl;
+ *    misc_rate_ctrl= (VAEncMiscParameterRateControl *)misc_param->data;
+ *    misc_rate_ctrl->bits_per_second = 6400000;
+ *    vaUnmapBuffer(dpy, buf_id);
+ *    vaRenderPicture(dpy, context, &buf_id, 1);
+ */
+typedef struct _VAEncMiscParameterBuffer
+{
+    VAEncMiscParameterType type;
+    unsigned int data[0];
+} VAEncMiscParameterBuffer;
+
+
+/** \brief Rate control parameters */
+typedef struct _VAEncMiscParameterRateControl
+{
+    /* this is the maximum bit-rate to be constrained by the rate control implementation */
+    unsigned int bits_per_second;
+    /* this is the bit-rate the rate control is targeting, as a percentage of the maximum
+     * bit-rate for example if target_percentage is 95 then the rate control will target
+     * a bit-rate that is 95% of the maximum bit-rate
+     */
+    unsigned int target_percentage;
+    /* windows size in milliseconds. For example if this is set to 500,
+     * then the rate control will guarantee the target bit-rate over a 500 ms window
+     */
+    unsigned int window_size;
+    /* initial QP at I frames */
+    unsigned int initial_qp;
+    unsigned int min_qp;
+    unsigned int basic_unit_size;
+    union
+    {
+        struct
+        {
+            unsigned int reset : 1;
+            unsigned int disable_frame_skip : 1; /* Disable frame skip in rate control mode */
+            unsigned int disable_bit_stuffing : 1; /* Disable bit stuffing in rate control mode */
+        } bits;
+        unsigned int value;
+    } rc_flags;
+} VAEncMiscParameterRateControl;
+
+typedef struct _VAEncMiscParameterFrameRate
+{
+    unsigned int framerate;
+} VAEncMiscParameterFrameRate;
+
+/**
+ * Allow a maximum slice size to be specified (in bits).
+ * The encoder will attempt to make sure that individual slices do not exceed this size
+ * Or to signal applicate if the slice size exceed this size, see "status" of VACodedBufferSegment
+ */
+typedef struct _VAEncMiscParameterMaxSliceSize
+{
+    unsigned int max_slice_size;
+} VAEncMiscParameterMaxSliceSize;
+
+typedef struct _VAEncMiscParameterAIR
+{
+    unsigned int air_num_mbs;
+    unsigned int air_threshold;
+    unsigned int air_auto; /* if set to 1 then hardware auto-tune the AIR threshold */
+} VAEncMiscParameterAIR;
+
+typedef struct _VAEncMiscParameterHRD
+{
+    unsigned int initial_buffer_fullness;       /* in bits */
+    unsigned int buffer_size;                   /* in bits */
+} VAEncMiscParameterHRD;
+
+/**
+ * \brief Defines a maximum frame size (in bits).
+ *
+ * This misc parameter buffer defines the maximum size of a frame (in
+ * bits). The encoder will try to make sure that each frame does not
+ * exceed this size. Otherwise, if the frame size exceeds this size,
+ * the \c status flag of #VACodedBufferSegment will contain
+ * #VA_CODED_BUF_STATUS_FRAME_SIZE_OVERFLOW.
+ */
+typedef struct _VAEncMiscParameterBufferMaxFrameSize {
+    /** \brief Type. Shall be set to #VAEncMiscParameterTypeMaxFrameSize. */
+    VAEncMiscParameterType      type;
+    /** \brief Maximum size of a frame (in bits). */
+    unsigned int                max_frame_size;
+} VAEncMiscParameterBufferMaxFrameSize;
+
+/**
+ * \brief Encoding quality level.
+ *
+ * The encoding quality could be set through this structure, if the implementation  
+ * supports multiple quality levels. The quality level set through this structure is 
+ * persistent over the entire coded sequence, or until a new structure is being sent.
+ * The quality level range can be queried through the VAConfigAttribEncQualityRange 
+ * attribute. A lower value means higher quality, and a value of 1 represents the highest 
+ * quality. The quality level setting is used as a trade-off between quality and speed/power 
+ * consumption, with higher quality corresponds to lower speed and higher power consumption. 
+ */
+typedef struct _VAEncMiscParameterBufferQualityLevel {
+    /** \brief Encoding quality level setting. When set to 0, default quality
+     * level is used.
+     */
+    unsigned int                quality_level;
+} VAEncMiscParameterBufferQualityLevel;
+
+/**
+ * \brief Encoding skip frame.
+ *
+ * The application may choose to skip frames externally to the encoder (e.g. drop completely or 
+ * code as all skip's). For rate control purposes the encoder will need to know the size and number 
+ * of skipped frames.  Skip frame(s) indicated through this structure is applicable only to the 
+ * current frame.  It is allowed for the application to still send in packed headers for the driver to 
+ * pack, although no frame will be encoded (e.g. for HW to encrypt the frame).  
+ */
+typedef struct _VAEncMiscParameterSkipFrame {
+    /** \brief Indicates skip frames as below.
+      * 0: Encode as normal, no skip.
+      * 1: One or more frames were skipped prior to the current frame, encode the current frame as normal.  
+      * 2: The current frame is to be skipped, do not encode it but pack/encrypt the packed header contents
+      *    (all except VAEncPackedHeaderSlice) which could contain actual frame contents (e.g. pack the frame 
+      *    in VAEncPackedHeaderPicture).  */
+    unsigned char               skip_frame_flag;
+    /** \brief The number of frames skipped prior to the current frame.  Valid when skip_frame_flag = 1. */
+    unsigned char               num_skip_frames;
+    /** \brief When skip_frame_flag = 1, the size of the skipped frames in bits.   When skip_frame_flag = 2, 
+      * the size of the current skipped frame that is to be packed/encrypted in bits. */
+    unsigned int                size_skip_frames;
+} VAEncMiscParameterSkipFrame;
+
+/* 
+ * There will be cases where the bitstream buffer will not have enough room to hold
+ * the data for the entire slice, and the following flags will be used in the slice
+ * parameter to signal to the server for the possible cases.
+ * If a slice parameter buffer and slice data buffer pair is sent to the server with 
+ * the slice data partially in the slice data buffer (BEGIN and MIDDLE cases below), 
+ * then a slice parameter and data buffer needs to be sent again to complete this slice. 
+ */
+#define VA_SLICE_DATA_FLAG_ALL		0x00	/* whole slice is in the buffer */
+#define VA_SLICE_DATA_FLAG_BEGIN	0x01	/* The beginning of the slice is in the buffer but the end if not */
+#define VA_SLICE_DATA_FLAG_MIDDLE	0x02	/* Neither beginning nor end of the slice is in the buffer */
+#define VA_SLICE_DATA_FLAG_END		0x04	/* end of the slice is in the buffer */
+
+/* Codec-independent Slice Parameter Buffer base */
+typedef struct _VASliceParameterBufferBase
+{
+    unsigned int slice_data_size;	/* number of bytes in the slice data buffer for this slice */
+    unsigned int slice_data_offset;	/* the offset to the first byte of slice data */
+    unsigned int slice_data_flag;	/* see VA_SLICE_DATA_FLAG_XXX definitions */
+} VASliceParameterBufferBase;
+
+/**********************************
+ * JPEG common  data structures
+ **********************************/
+/**
+ * \brief Huffman table for JPEG decoding.
+ *
+ * This structure holds the complete Huffman tables. This is an
+ * aggregation of all Huffman table (DHT) segments maintained by the
+ * application. i.e. up to 2 Huffman tables are stored in there for
+ * baseline profile.
+ *
+ * The #load_huffman_table array can be used as a hint to notify the
+ * VA driver implementation about which table(s) actually changed
+ * since the last submission of this buffer.
+ */
+typedef struct _VAHuffmanTableBufferJPEGBaseline {
+    /** \brief Specifies which #huffman_table is valid. */
+    unsigned char       load_huffman_table[2];
+    /** \brief Huffman tables indexed by table identifier (Th). */
+    struct {
+        /** @name DC table (up to 12 categories) */
+        /**@{*/
+        /** \brief Number of Huffman codes of length i + 1 (Li). */
+        unsigned char   num_dc_codes[16];
+        /** \brief Value associated with each Huffman code (Vij). */
+        unsigned char   dc_values[12];
+        /**@}*/
+        /** @name AC table (2 special codes + up to 16 * 10 codes) */
+        /**@{*/
+        /** \brief Number of Huffman codes of length i + 1 (Li). */
+        unsigned char   num_ac_codes[16];
+        /** \brief Value associated with each Huffman code (Vij). */
+        unsigned char   ac_values[162];
+        /** \brief Padding to 4-byte boundaries. Must be set to zero. */
+        unsigned char   pad[2];
+        /**@}*/
+    }                   huffman_table[2];
+} VAHuffmanTableBufferJPEGBaseline;
+
+/****************************
+ * MPEG-2 data structures
+ ****************************/
+ 
+/* MPEG-2 Picture Parameter Buffer */
+/* 
+ * For each frame or field, and before any slice data, a single
+ * picture parameter buffer must be send.
+ */
+typedef struct _VAPictureParameterBufferMPEG2
+{
+    unsigned short horizontal_size;
+    unsigned short vertical_size;
+    VASurfaceID forward_reference_picture;
+    VASurfaceID backward_reference_picture;
+    /* meanings of the following fields are the same as in the standard */
+    int picture_coding_type;
+    int f_code; /* pack all four fcode into this */
+    union {
+        struct {
+            unsigned int intra_dc_precision		: 2; 
+            unsigned int picture_structure		: 2; 
+            unsigned int top_field_first		: 1; 
+            unsigned int frame_pred_frame_dct		: 1; 
+            unsigned int concealment_motion_vectors	: 1;
+            unsigned int q_scale_type			: 1;
+            unsigned int intra_vlc_format		: 1;
+            unsigned int alternate_scan			: 1;
+            unsigned int repeat_first_field		: 1;
+            unsigned int progressive_frame		: 1;
+            unsigned int is_first_field			: 1; /* indicate whether the current field
+                                                              * is the first field for field picture
+                                                              */
+        } bits;
+        unsigned int value;
+    } picture_coding_extension;
+} VAPictureParameterBufferMPEG2;
+
+/** MPEG-2 Inverse Quantization Matrix Buffer */
+typedef struct _VAIQMatrixBufferMPEG2
+{
+    /** \brief Same as the MPEG-2 bitstream syntax element. */
+    int load_intra_quantiser_matrix;
+    /** \brief Same as the MPEG-2 bitstream syntax element. */
+    int load_non_intra_quantiser_matrix;
+    /** \brief Same as the MPEG-2 bitstream syntax element. */
+    int load_chroma_intra_quantiser_matrix;
+    /** \brief Same as the MPEG-2 bitstream syntax element. */
+    int load_chroma_non_intra_quantiser_matrix;
+    /** \brief Luminance intra matrix, in zig-zag scan order. */
+    unsigned char intra_quantiser_matrix[64];
+    /** \brief Luminance non-intra matrix, in zig-zag scan order. */
+    unsigned char non_intra_quantiser_matrix[64];
+    /** \brief Chroma intra matrix, in zig-zag scan order. */
+    unsigned char chroma_intra_quantiser_matrix[64];
+    /** \brief Chroma non-intra matrix, in zig-zag scan order. */
+    unsigned char chroma_non_intra_quantiser_matrix[64];
+} VAIQMatrixBufferMPEG2;
+
+/** MPEG-2 Slice Parameter Buffer */
+typedef struct _VASliceParameterBufferMPEG2
+{
+    unsigned int slice_data_size;/* number of bytes in the slice data buffer for this slice */
+    unsigned int slice_data_offset;/* the offset to the first byte of slice data */
+    unsigned int slice_data_flag; /* see VA_SLICE_DATA_FLAG_XXX defintions */
+    unsigned int macroblock_offset;/* the offset to the first bit of MB from the first byte of slice data */
+    unsigned int slice_horizontal_position;
+    unsigned int slice_vertical_position;
+    int quantiser_scale_code;
+    int intra_slice_flag;
+} VASliceParameterBufferMPEG2;
+
+/** MPEG-2 Macroblock Parameter Buffer */
+typedef struct _VAMacroblockParameterBufferMPEG2
+{
+    unsigned short macroblock_address;
+    /* 
+     * macroblock_address (in raster scan order)
+     * top-left: 0
+     * bottom-right: picture-height-in-mb*picture-width-in-mb - 1
+     */
+    unsigned char macroblock_type;  /* see definition below */
+    union {
+        struct {
+            unsigned int frame_motion_type		: 2; 
+            unsigned int field_motion_type		: 2; 
+            unsigned int dct_type			: 1; 
+        } bits;
+        unsigned int value;
+    } macroblock_modes;
+    unsigned char motion_vertical_field_select; 
+    /* 
+     * motion_vertical_field_select:
+     * see section 6.3.17.2 in the spec
+     * only the lower 4 bits are used
+     * bit 0: first vector forward
+     * bit 1: first vector backward
+     * bit 2: second vector forward
+     * bit 3: second vector backward
+     */
+    short PMV[2][2][2]; /* see Table 7-7 in the spec */
+    unsigned short coded_block_pattern;
+    /* 
+     * The bitplanes for coded_block_pattern are described 
+     * in Figure 6.10-12 in the spec
+     */
+     
+    /* Number of skipped macroblocks after this macroblock */
+    unsigned short num_skipped_macroblocks;
+} VAMacroblockParameterBufferMPEG2;
+
+/* 
+ * OR'd flags for macroblock_type (section 6.3.17.1 in the spec)
+ */
+#define VA_MB_TYPE_MOTION_FORWARD	0x02
+#define VA_MB_TYPE_MOTION_BACKWARD	0x04
+#define VA_MB_TYPE_MOTION_PATTERN	0x08
+#define VA_MB_TYPE_MOTION_INTRA		0x10
+
+/**
+ * MPEG-2 Residual Data Buffer 
+ * For each macroblock, there wil be 64 shorts (16-bit) in the 
+ * residual data buffer
+ */
+
+/****************************
+ * MPEG-4 Part 2 data structures
+ ****************************/
+ 
+/* MPEG-4 Picture Parameter Buffer */
+/* 
+ * For each frame or field, and before any slice data, a single
+ * picture parameter buffer must be send.
+ */
+typedef struct _VAPictureParameterBufferMPEG4
+{
+    unsigned short vop_width;
+    unsigned short vop_height;
+    VASurfaceID forward_reference_picture;
+    VASurfaceID backward_reference_picture;
+    union {
+        struct {
+            unsigned int short_video_header		: 1; 
+            unsigned int chroma_format			: 2; 
+            unsigned int interlaced			: 1; 
+            unsigned int obmc_disable			: 1; 
+            unsigned int sprite_enable			: 2; 
+            unsigned int sprite_warping_accuracy	: 2; 
+            unsigned int quant_type			: 1; 
+            unsigned int quarter_sample			: 1; 
+            unsigned int data_partitioned		: 1; 
+            unsigned int reversible_vlc			: 1; 
+            unsigned int resync_marker_disable		: 1; 
+        } bits;
+        unsigned int value;
+    } vol_fields;
+    unsigned char no_of_sprite_warping_points;
+    short sprite_trajectory_du[3];
+    short sprite_trajectory_dv[3];
+    unsigned char quant_precision;
+    union {
+        struct {
+            unsigned int vop_coding_type		: 2; 
+            unsigned int backward_reference_vop_coding_type	: 2; 
+            unsigned int vop_rounding_type		: 1; 
+            unsigned int intra_dc_vlc_thr		: 3; 
+            unsigned int top_field_first		: 1; 
+            unsigned int alternate_vertical_scan_flag	: 1; 
+        } bits;
+        unsigned int value;
+    } vop_fields;
+    unsigned char vop_fcode_forward;
+    unsigned char vop_fcode_backward;
+    unsigned short vop_time_increment_resolution;
+    /* short header related */
+    unsigned char num_gobs_in_vop;
+    unsigned char num_macroblocks_in_gob;
+    /* for direct mode prediction */
+    short TRB;
+    short TRD;
+} VAPictureParameterBufferMPEG4;
+
+/** MPEG-4 Inverse Quantization Matrix Buffer */
+typedef struct _VAIQMatrixBufferMPEG4
+{
+    /** Same as the MPEG-4:2 bitstream syntax element. */
+    int load_intra_quant_mat;
+    /** Same as the MPEG-4:2 bitstream syntax element. */
+    int load_non_intra_quant_mat;
+    /** The matrix for intra blocks, in zig-zag scan order. */
+    unsigned char intra_quant_mat[64];
+    /** The matrix for non-intra blocks, in zig-zag scan order. */
+    unsigned char non_intra_quant_mat[64];
+} VAIQMatrixBufferMPEG4;
+
+/** MPEG-4 Slice Parameter Buffer */
+typedef struct _VASliceParameterBufferMPEG4
+{
+    unsigned int slice_data_size;/* number of bytes in the slice data buffer for this slice */
+    unsigned int slice_data_offset;/* the offset to the first byte of slice data */
+    unsigned int slice_data_flag; /* see VA_SLICE_DATA_FLAG_XXX defintions */
+    unsigned int macroblock_offset;/* the offset to the first bit of MB from the first byte of slice data */
+    unsigned int macroblock_number;
+    int quant_scale;
+} VASliceParameterBufferMPEG4;
+
+/**
+ VC-1 data structures
+*/
+
+typedef enum   /* see 7.1.1.32 */
+{
+    VAMvMode1Mv                        = 0,
+    VAMvMode1MvHalfPel                 = 1,
+    VAMvMode1MvHalfPelBilinear         = 2,
+    VAMvModeMixedMv                    = 3,
+    VAMvModeIntensityCompensation      = 4 
+} VAMvModeVC1;
+
+/** VC-1 Picture Parameter Buffer */
+/* 
+ * For each picture, and before any slice data, a picture parameter
+ * buffer must be send. Multiple picture parameter buffers may be
+ * sent for a single picture. In that case picture parameters will
+ * apply to all slice data that follow it until a new picture
+ * parameter buffer is sent.
+ *
+ * Notes:
+ *   pic_quantizer_type should be set to the applicable quantizer
+ *   type as defined by QUANTIZER (J.1.19) and either
+ *   PQUANTIZER (7.1.1.8) or PQINDEX (7.1.1.6)
+ */
+typedef struct _VAPictureParameterBufferVC1
+{
+    VASurfaceID forward_reference_picture;
+    VASurfaceID backward_reference_picture;
+    /* if out-of-loop post-processing is done on the render
+       target, then we need to keep the in-loop decoded 
+       picture as a reference picture */
+    VASurfaceID inloop_decoded_picture;
+
+    /* sequence layer for AP or meta data for SP and MP */
+    union {
+        struct {
+            unsigned int pulldown	: 1; /* SEQUENCE_LAYER::PULLDOWN */
+            unsigned int interlace	: 1; /* SEQUENCE_LAYER::INTERLACE */
+            unsigned int tfcntrflag	: 1; /* SEQUENCE_LAYER::TFCNTRFLAG */
+            unsigned int finterpflag	: 1; /* SEQUENCE_LAYER::FINTERPFLAG */
+            unsigned int psf		: 1; /* SEQUENCE_LAYER::PSF */
+            unsigned int multires	: 1; /* METADATA::MULTIRES */
+            unsigned int overlap	: 1; /* METADATA::OVERLAP */
+            unsigned int syncmarker	: 1; /* METADATA::SYNCMARKER */
+            unsigned int rangered	: 1; /* METADATA::RANGERED */
+            unsigned int max_b_frames	: 3; /* METADATA::MAXBFRAMES */
+            unsigned int profile	: 2; /* SEQUENCE_LAYER::PROFILE or The MSB of METADATA::PROFILE */
+        } bits;
+        unsigned int value;
+    } sequence_fields;
+
+    unsigned short coded_width;		/* ENTRY_POINT_LAYER::CODED_WIDTH */
+    unsigned short coded_height;	/* ENTRY_POINT_LAYER::CODED_HEIGHT */
+    union {
+	struct {
+            unsigned int broken_link	: 1; /* ENTRY_POINT_LAYER::BROKEN_LINK */
+            unsigned int closed_entry	: 1; /* ENTRY_POINT_LAYER::CLOSED_ENTRY */
+            unsigned int panscan_flag	: 1; /* ENTRY_POINT_LAYER::PANSCAN_FLAG */
+            unsigned int loopfilter	: 1; /* ENTRY_POINT_LAYER::LOOPFILTER */
+	} bits;
+	unsigned int value;
+    } entrypoint_fields;
+    unsigned char conditional_overlap_flag; /* ENTRY_POINT_LAYER::CONDOVER */
+    unsigned char fast_uvmc_flag;	/* ENTRY_POINT_LAYER::FASTUVMC */
+    union {
+        struct {
+            unsigned int luma_flag	: 1; /* ENTRY_POINT_LAYER::RANGE_MAPY_FLAG */
+            unsigned int luma		: 3; /* ENTRY_POINT_LAYER::RANGE_MAPY */
+            unsigned int chroma_flag	: 1; /* ENTRY_POINT_LAYER::RANGE_MAPUV_FLAG */
+            unsigned int chroma		: 3; /* ENTRY_POINT_LAYER::RANGE_MAPUV */
+        } bits;
+        unsigned int value;
+    } range_mapping_fields;
+
+    unsigned char b_picture_fraction;	/* PICTURE_LAYER::BFRACTION */
+    unsigned char cbp_table;		/* PICTURE_LAYER::CBPTAB/ICBPTAB */
+    unsigned char mb_mode_table;	/* PICTURE_LAYER::MBMODETAB */
+    unsigned char range_reduction_frame;/* PICTURE_LAYER::RANGEREDFRM */
+    unsigned char rounding_control;	/* PICTURE_LAYER::RNDCTRL */
+    unsigned char post_processing;	/* PICTURE_LAYER::POSTPROC */
+    unsigned char picture_resolution_index;	/* PICTURE_LAYER::RESPIC */
+    unsigned char luma_scale;		/* PICTURE_LAYER::LUMSCALE */
+    unsigned char luma_shift;		/* PICTURE_LAYER::LUMSHIFT */
+    union {
+        struct {
+            unsigned int picture_type		: 3; /* PICTURE_LAYER::PTYPE */
+            unsigned int frame_coding_mode	: 3; /* PICTURE_LAYER::FCM */
+            unsigned int top_field_first	: 1; /* PICTURE_LAYER::TFF */
+            unsigned int is_first_field		: 1; /* set to 1 if it is the first field */
+            unsigned int intensity_compensation	: 1; /* PICTURE_LAYER::INTCOMP */
+        } bits;
+        unsigned int value;
+    } picture_fields;
+    union {
+        struct {
+            unsigned int mv_type_mb	: 1; 	/* PICTURE::MVTYPEMB */
+            unsigned int direct_mb	: 1; 	/* PICTURE::DIRECTMB */
+            unsigned int skip_mb	: 1; 	/* PICTURE::SKIPMB */
+            unsigned int field_tx	: 1; 	/* PICTURE::FIELDTX */
+            unsigned int forward_mb	: 1;	/* PICTURE::FORWARDMB */
+            unsigned int ac_pred	: 1;	/* PICTURE::ACPRED */
+            unsigned int overflags	: 1;	/* PICTURE::OVERFLAGS */
+        } flags;
+        unsigned int value;
+    } raw_coding;
+    union {
+        struct {
+            unsigned int bp_mv_type_mb   : 1;    /* PICTURE::MVTYPEMB */
+            unsigned int bp_direct_mb    : 1;    /* PICTURE::DIRECTMB */
+            unsigned int bp_skip_mb      : 1;    /* PICTURE::SKIPMB */  
+            unsigned int bp_field_tx     : 1;    /* PICTURE::FIELDTX */ 
+            unsigned int bp_forward_mb   : 1;    /* PICTURE::FORWARDMB */
+            unsigned int bp_ac_pred      : 1;    /* PICTURE::ACPRED */   
+            unsigned int bp_overflags    : 1;    /* PICTURE::OVERFLAGS */
+        } flags;
+        unsigned int value;
+    } bitplane_present; /* signal what bitplane is being passed via the bitplane buffer */
+    union {
+        struct {
+            unsigned int reference_distance_flag : 1;/* PICTURE_LAYER::REFDIST_FLAG */
+            unsigned int reference_distance	: 5;/* PICTURE_LAYER::REFDIST */
+            unsigned int num_reference_pictures: 1;/* PICTURE_LAYER::NUMREF */
+            unsigned int reference_field_pic_indicator	: 1;/* PICTURE_LAYER::REFFIELD */
+        } bits;
+        unsigned int value;
+    } reference_fields;
+    union {
+        struct {
+            unsigned int mv_mode		: 3; /* PICTURE_LAYER::MVMODE */
+            unsigned int mv_mode2		: 3; /* PICTURE_LAYER::MVMODE2 */
+            unsigned int mv_table		: 3; /* PICTURE_LAYER::MVTAB/IMVTAB */
+            unsigned int two_mv_block_pattern_table: 2; /* PICTURE_LAYER::2MVBPTAB */
+            unsigned int four_mv_switch		: 1; /* PICTURE_LAYER::4MVSWITCH */
+            unsigned int four_mv_block_pattern_table : 2; /* PICTURE_LAYER::4MVBPTAB */
+            unsigned int extended_mv_flag	: 1; /* ENTRY_POINT_LAYER::EXTENDED_MV */
+            unsigned int extended_mv_range	: 2; /* PICTURE_LAYER::MVRANGE */
+            unsigned int extended_dmv_flag	: 1; /* ENTRY_POINT_LAYER::EXTENDED_DMV */
+            unsigned int extended_dmv_range	: 2; /* PICTURE_LAYER::DMVRANGE */
+        } bits;
+        unsigned int value;
+    } mv_fields;
+    union {
+        struct {
+            unsigned int dquant	: 2; 	/* ENTRY_POINT_LAYER::DQUANT */
+            unsigned int quantizer     : 2; 	/* ENTRY_POINT_LAYER::QUANTIZER */
+            unsigned int half_qp	: 1; 	/* PICTURE_LAYER::HALFQP */
+            unsigned int pic_quantizer_scale : 5;/* PICTURE_LAYER::PQUANT */
+            unsigned int pic_quantizer_type : 1;/* PICTURE_LAYER::PQUANTIZER */
+            unsigned int dq_frame	: 1; 	/* VOPDQUANT::DQUANTFRM */
+            unsigned int dq_profile	: 2; 	/* VOPDQUANT::DQPROFILE */
+            unsigned int dq_sb_edge	: 2; 	/* VOPDQUANT::DQSBEDGE */
+            unsigned int dq_db_edge 	: 2; 	/* VOPDQUANT::DQDBEDGE */
+            unsigned int dq_binary_level : 1; 	/* VOPDQUANT::DQBILEVEL */
+            unsigned int alt_pic_quantizer : 5;/* VOPDQUANT::ALTPQUANT */
+        } bits;
+        unsigned int value;
+    } pic_quantizer_fields;
+    union {
+        struct {
+            unsigned int variable_sized_transform_flag	: 1;/* ENTRY_POINT_LAYER::VSTRANSFORM */
+            unsigned int mb_level_transform_type_flag	: 1;/* PICTURE_LAYER::TTMBF */
+            unsigned int frame_level_transform_type	: 2;/* PICTURE_LAYER::TTFRM */
+            unsigned int transform_ac_codingset_idx1	: 2;/* PICTURE_LAYER::TRANSACFRM */
+            unsigned int transform_ac_codingset_idx2	: 2;/* PICTURE_LAYER::TRANSACFRM2 */
+            unsigned int intra_transform_dc_table	: 1;/* PICTURE_LAYER::TRANSDCTAB */
+        } bits;
+        unsigned int value;
+    } transform_fields;
+} VAPictureParameterBufferVC1;
+
+/** VC-1 Bitplane Buffer
+There will be at most three bitplanes coded in any picture header. To send 
+the bitplane data more efficiently, each byte is divided in two nibbles, with
+each nibble carrying three bitplanes for one macroblock.  The following table
+shows the bitplane data arrangement within each nibble based on the picture
+type.
+
+Picture Type	Bit3		Bit2		Bit1		Bit0
+I or BI				OVERFLAGS	ACPRED		FIELDTX
+P				MYTYPEMB	SKIPMB		DIRECTMB
+B				FORWARDMB	SKIPMB		DIRECTMB
+
+Within each byte, the lower nibble is for the first MB and the upper nibble is 
+for the second MB.  E.g. the lower nibble of the first byte in the bitplane
+buffer is for Macroblock #1 and the upper nibble of the first byte is for 
+Macroblock #2 in the first row.
+*/
+
+/* VC-1 Slice Parameter Buffer */
+typedef struct _VASliceParameterBufferVC1
+{
+    unsigned int slice_data_size;/* number of bytes in the slice data buffer for this slice */
+    unsigned int slice_data_offset;/* the offset to the first byte of slice data */
+    unsigned int slice_data_flag; /* see VA_SLICE_DATA_FLAG_XXX defintions */
+    unsigned int macroblock_offset;/* the offset to the first bit of MB from the first byte of slice data */
+    unsigned int slice_vertical_position;
+} VASliceParameterBufferVC1;
+
+/* VC-1 Slice Data Buffer */
+/* 
+This is simplely a buffer containing raw bit-stream bytes 
+*/
+
+/****************************
+ * H.264/AVC data structures
+ ****************************/
+
+typedef struct _VAPictureH264
+{
+    VASurfaceID picture_id;
+    unsigned int frame_idx;
+    unsigned int flags;
+    signed int TopFieldOrderCnt;
+    signed int BottomFieldOrderCnt;
+} VAPictureH264;
+/* flags in VAPictureH264 could be OR of the following */
+#define VA_PICTURE_H264_INVALID			0x00000001
+#define VA_PICTURE_H264_TOP_FIELD		0x00000002
+#define VA_PICTURE_H264_BOTTOM_FIELD		0x00000004
+#define VA_PICTURE_H264_SHORT_TERM_REFERENCE	0x00000008
+#define VA_PICTURE_H264_LONG_TERM_REFERENCE	0x00000010
+
+/** H.264 Picture Parameter Buffer */
+/* 
+ * For each picture, and before any slice data, a single
+ * picture parameter buffer must be send.
+ */
+typedef struct _VAPictureParameterBufferH264
+{
+    VAPictureH264 CurrPic;
+    VAPictureH264 ReferenceFrames[16];	/* in DPB */
+    unsigned short picture_width_in_mbs_minus1;
+    unsigned short picture_height_in_mbs_minus1;
+    unsigned char bit_depth_luma_minus8;
+    unsigned char bit_depth_chroma_minus8;
+    unsigned char num_ref_frames;
+    union {
+        struct {
+            unsigned int chroma_format_idc			: 2; 
+            unsigned int residual_colour_transform_flag		: 1; 
+            unsigned int gaps_in_frame_num_value_allowed_flag	: 1; 
+            unsigned int frame_mbs_only_flag			: 1; 
+            unsigned int mb_adaptive_frame_field_flag		: 1; 
+            unsigned int direct_8x8_inference_flag		: 1; 
+            unsigned int MinLumaBiPredSize8x8			: 1; /* see A.3.3.2 */
+            unsigned int log2_max_frame_num_minus4		: 4;
+            unsigned int pic_order_cnt_type			: 2;
+            unsigned int log2_max_pic_order_cnt_lsb_minus4	: 4;
+            unsigned int delta_pic_order_always_zero_flag	: 1;
+        } bits;
+        unsigned int value;
+    } seq_fields;
+    unsigned char num_slice_groups_minus1;
+    unsigned char slice_group_map_type;
+    unsigned short slice_group_change_rate_minus1;
+    signed char pic_init_qp_minus26;
+    signed char pic_init_qs_minus26;
+    signed char chroma_qp_index_offset;
+    signed char second_chroma_qp_index_offset;
+    union {
+        struct {
+            unsigned int entropy_coding_mode_flag	: 1;
+            unsigned int weighted_pred_flag		: 1;
+            unsigned int weighted_bipred_idc		: 2;
+            unsigned int transform_8x8_mode_flag	: 1;
+            unsigned int field_pic_flag			: 1;
+            unsigned int constrained_intra_pred_flag	: 1;
+            unsigned int pic_order_present_flag			: 1;
+            unsigned int deblocking_filter_control_present_flag : 1;
+            unsigned int redundant_pic_cnt_present_flag		: 1;
+            unsigned int reference_pic_flag			: 1; /* nal_ref_idc != 0 */
+        } bits;
+        unsigned int value;
+    } pic_fields;
+    unsigned short frame_num;
+} VAPictureParameterBufferH264;
+
+/** H.264 Inverse Quantization Matrix Buffer */
+typedef struct _VAIQMatrixBufferH264
+{
+    /** \brief 4x4 scaling list, in raster scan order. */
+    unsigned char ScalingList4x4[6][16];
+    /** \brief 8x8 scaling list, in raster scan order. */
+    unsigned char ScalingList8x8[2][64];
+} VAIQMatrixBufferH264;
+
+/**
+ * H.264 Slice Group Map Buffer 
+ * When VAPictureParameterBufferH264::num_slice_group_minus1 is not equal to 0,
+ * A slice group map buffer should be sent for each picture if required. The buffer
+ * is sent only when there is a change in the mapping values.
+ * The slice group map buffer map "map units" to slice groups as specified in 
+ * section 8.2.2 of the H.264 spec. The buffer will contain one byte for each macroblock 
+ * in raster scan order
+ */ 
+
+/** H.264 Slice Parameter Buffer */
+typedef struct _VASliceParameterBufferH264
+{
+    unsigned int slice_data_size;/* number of bytes in the slice data buffer for this slice */
+    /** \brief Byte offset to the NAL Header Unit for this slice. */
+    unsigned int slice_data_offset;
+    unsigned int slice_data_flag; /* see VA_SLICE_DATA_FLAG_XXX defintions */
+    /**
+     * \brief Bit offset from NAL Header Unit to the begining of slice_data().
+     *
+     * This bit offset is relative to and includes the NAL unit byte
+     * and represents the number of bits parsed in the slice_header()
+     * after the removal of any emulation prevention bytes in
+     * there. However, the slice data buffer passed to the hardware is
+     * the original bitstream, thus including any emulation prevention
+     * bytes.
+     */
+    unsigned short slice_data_bit_offset;
+    unsigned short first_mb_in_slice;
+    unsigned char slice_type;
+    unsigned char direct_spatial_mv_pred_flag;
+    unsigned char num_ref_idx_l0_active_minus1;
+    unsigned char num_ref_idx_l1_active_minus1;
+    unsigned char cabac_init_idc;
+    char slice_qp_delta;
+    unsigned char disable_deblocking_filter_idc;
+    char slice_alpha_c0_offset_div2;
+    char slice_beta_offset_div2;
+    VAPictureH264 RefPicList0[32];	/* See 8.2.4.2 */
+    VAPictureH264 RefPicList1[32];	/* See 8.2.4.2 */
+    unsigned char luma_log2_weight_denom;
+    unsigned char chroma_log2_weight_denom;
+    unsigned char luma_weight_l0_flag;
+    short luma_weight_l0[32];
+    short luma_offset_l0[32];
+    unsigned char chroma_weight_l0_flag;
+    short chroma_weight_l0[32][2];
+    short chroma_offset_l0[32][2];
+    unsigned char luma_weight_l1_flag;
+    short luma_weight_l1[32];
+    short luma_offset_l1[32];
+    unsigned char chroma_weight_l1_flag;
+    short chroma_weight_l1[32][2];
+    short chroma_offset_l1[32][2];
+} VASliceParameterBufferH264;
+
+/****************************
+ * Common encode data structures 
+ ****************************/
+typedef enum
+{
+    VAEncPictureTypeIntra		= 0,
+    VAEncPictureTypePredictive		= 1,
+    VAEncPictureTypeBidirectional	= 2,
+} VAEncPictureType;
+
+/* Encode Slice Parameter Buffer */
+typedef struct _VAEncSliceParameterBuffer
+{
+    unsigned int start_row_number;	/* starting MB row number for this slice */
+    unsigned int slice_height;	/* slice height measured in MB */
+    union {
+        struct {
+            unsigned int is_intra	: 1;
+            unsigned int disable_deblocking_filter_idc : 2;
+            unsigned int uses_long_term_ref		:1;
+            unsigned int is_long_term_ref		:1;
+        } bits;
+        unsigned int value;
+    } slice_flags;
+} VAEncSliceParameterBuffer;
+
+
+/****************************
+ * H.263 specific encode data structures
+ ****************************/
+
+typedef struct _VAEncSequenceParameterBufferH263
+{
+    unsigned int intra_period;
+    unsigned int bits_per_second;
+    unsigned int frame_rate;
+    unsigned int initial_qp;
+    unsigned int min_qp;
+} VAEncSequenceParameterBufferH263;
+
+typedef struct _VAEncPictureParameterBufferH263
+{
+    VASurfaceID reference_picture;
+    VASurfaceID reconstructed_picture;
+    VABufferID coded_buf;
+    unsigned short picture_width;
+    unsigned short picture_height;
+    VAEncPictureType picture_type;
+} VAEncPictureParameterBufferH263;
+
+/****************************
+ * MPEG-4 specific encode data structures
+ ****************************/
+
+typedef struct _VAEncSequenceParameterBufferMPEG4
+{
+    unsigned char profile_and_level_indication;
+    unsigned int intra_period;
+    unsigned int video_object_layer_width;
+    unsigned int video_object_layer_height;
+    unsigned int vop_time_increment_resolution;
+    unsigned int fixed_vop_rate;
+    unsigned int fixed_vop_time_increment;
+    unsigned int bits_per_second;
+    unsigned int frame_rate;
+    unsigned int initial_qp;
+    unsigned int min_qp;
+} VAEncSequenceParameterBufferMPEG4;
+
+typedef struct _VAEncPictureParameterBufferMPEG4
+{
+    VASurfaceID reference_picture;
+    VASurfaceID reconstructed_picture;
+    VABufferID coded_buf;
+    unsigned short picture_width;
+    unsigned short picture_height;
+    unsigned int modulo_time_base; /* number of 1s */
+    unsigned int vop_time_increment;
+    VAEncPictureType picture_type;
+} VAEncPictureParameterBufferMPEG4;
+
+
+
+/** Buffer functions */
+
+/**
+ * Creates a buffer for "num_elements" elements of "size" bytes and 
+ * initalize with "data".
+ * if "data" is null, then the contents of the buffer data store
+ * are undefined.
+ * Basically there are two ways to get buffer data to the server side. One is 
+ * to call vaCreateBuffer() with a non-null "data", which results the data being
+ * copied to the data store on the server side.  A different method that 
+ * eliminates this copy is to pass null as "data" when calling vaCreateBuffer(),
+ * and then use vaMapBuffer() to map the data store from the server side to the
+ * client address space for access.
+ *  Note: image buffers are created by the library, not the client. Please see 
+ *        vaCreateImage on how image buffers are managed.
+ */
+VAStatus vaCreateBuffer (
+    VADisplay dpy,
+    VAContextID context,
+    VABufferType type,	/* in */
+    unsigned int size,	/* in */
+    unsigned int num_elements, /* in */
+    void *data,		/* in */
+    VABufferID *buf_id	/* out */
+);
+
+/**
+ * Convey to the server how many valid elements are in the buffer. 
+ * e.g. if multiple slice parameters are being held in a single buffer,
+ * this will communicate to the server the number of slice parameters
+ * that are valid in the buffer.
+ */
+VAStatus vaBufferSetNumElements (
+    VADisplay dpy,
+    VABufferID buf_id,	/* in */
+    unsigned int num_elements /* in */
+);
+
+
+/**
+ * device independent data structure for codedbuffer
+ */
+
+/* 
+ * FICTURE_AVE_QP(bit7-0): The average Qp value used during this frame
+ * LARGE_SLICE(bit8):At least one slice in the current frame was large
+ *              enough for the encoder to attempt to limit its size.
+ * SLICE_OVERFLOW(bit9): At least one slice in the current frame has
+ *              exceeded the maximum slice size specified.
+ * BITRATE_OVERFLOW(bit10): The peak bitrate was exceeded for this frame.
+ * BITRATE_HIGH(bit11): The frame size got within the safety margin of the maximum size (VCM only)
+ * AIR_MB_OVER_THRESHOLD: the number of MBs adapted to Intra MB
+ */
+#define VA_CODED_BUF_STATUS_PICTURE_AVE_QP_MASK         0xff
+#define VA_CODED_BUF_STATUS_LARGE_SLICE_MASK            0x100
+#define VA_CODED_BUF_STATUS_SLICE_OVERFLOW_MASK         0x200
+#define VA_CODED_BUF_STATUS_BITRATE_OVERFLOW		0x400
+#define VA_CODED_BUF_STATUS_BITRATE_HIGH		0x800
+/**
+ * \brief The frame has exceeded the maximum requested size.
+ *
+ * This flag indicates that the encoded frame size exceeds the value
+ * specified through a misc parameter buffer of type
+ * #VAEncMiscParameterTypeMaxFrameSize.
+ */
+#define VA_CODED_BUF_STATUS_FRAME_SIZE_OVERFLOW         0x1000
+#define VA_CODED_BUF_STATUS_AIR_MB_OVER_THRESHOLD	0xff0000
+
+/**
+ * \brief The coded buffer segment contains a single NAL unit. 
+ *
+ * This flag indicates that the coded buffer segment contains a
+ * single NAL unit. This flag might be useful to the user for 
+ * processing the coded buffer.
+ */
+#define VA_CODED_BUF_STATUS_SINGLE_NALU                 0x10000000	
+
+/**
+ * \brief Coded buffer segment.
+ *
+ * #VACodedBufferSegment is an element of a linked list describing
+ * some information on the coded buffer. The coded buffer segment
+ * could contain either a single NAL unit, or more than one NAL unit. 
+ * It is recommended (but not required) to return a single NAL unit 
+ * in a coded buffer segment, and the implementation should set the 
+ * VA_CODED_BUF_STATUS_SINGLE_NALU status flag if that is the case.
+ */
+typedef  struct _VACodedBufferSegment  {
+    /**
+     * \brief Size of the data buffer in this segment (in bytes).
+     */
+    unsigned int        size;
+    /** \brief Bit offset into the data buffer where the video data starts. */
+    unsigned int        bit_offset;
+    /** \brief Status set by the driver. See \c VA_CODED_BUF_STATUS_*. */
+    unsigned int        status;
+    /** \brief Reserved for future use. */
+    unsigned int        reserved;
+    /** \brief Pointer to the start of the data buffer. */
+    void               *buf;
+    /**
+     * \brief Pointer to the next #VACodedBufferSegment element,
+     * or \c NULL if there is none.
+     */
+    void               *next;
+} VACodedBufferSegment;
+     
+/**
+ * Map data store of the buffer into the client's address space
+ * vaCreateBuffer() needs to be called with "data" set to NULL before
+ * calling vaMapBuffer()
+ *
+ * if buffer type is VAEncCodedBufferType, pbuf points to link-list of
+ * VACodedBufferSegment, and the list is terminated if "next" is NULL
+ */
+VAStatus vaMapBuffer (
+    VADisplay dpy,
+    VABufferID buf_id,	/* in */
+    void **pbuf 	/* out */
+);
+
+/**
+ * After client making changes to a mapped data store, it needs to
+ * "Unmap" it to let the server know that the data is ready to be
+ * consumed by the server
+ */
+VAStatus vaUnmapBuffer (
+    VADisplay dpy,
+    VABufferID buf_id	/* in */
+);
+
+/**
+ * After this call, the buffer is deleted and this buffer_id is no longer valid
+ * Only call this if the buffer is not going to be passed to vaRenderBuffer
+ */
+VAStatus vaDestroyBuffer (
+    VADisplay dpy,
+    VABufferID buffer_id
+);
+
+/** \brief VA buffer information */
+typedef struct {
+    /** \brief Buffer handle */
+    uintptr_t           handle;
+    /** \brief Buffer type (See \ref VABufferType). */
+    uint32_t            type;
+    /**
+     * \brief Buffer memory type (See \ref VASurfaceAttribMemoryType).
+     *
+     * On input to vaAcquireBufferHandle(), this field can serve as a hint
+     * to specify the set of memory types the caller is interested in.
+     * On successful return from vaAcquireBufferHandle(), the field is
+     * updated with the best matching memory type.
+     */
+    uint32_t            mem_type;
+    /** \brief Size of the underlying buffer. */
+    size_t              mem_size;
+} VABufferInfo;
+
+/**
+ * \brief Acquires buffer handle for external API usage
+ *
+ * Locks the VA buffer object \ref buf_id for external API usage like
+ * EGL or OpenCL (OCL). This function is a synchronization point. This
+ * means that any pending operation is guaranteed to be completed
+ * prior to returning from the function.
+ *
+ * If the referenced VA buffer object is the backing store of a VA
+ * surface, then this function acts as if vaSyncSurface() on the
+ * parent surface was called first.
+ *
+ * The \ref VABufferInfo argument shall be zero'ed on input. On
+ * successful output, the data structure is filled in with all the
+ * necessary buffer level implementation details like handle, type,
+ * memory type and memory size.
+ *
+ * Note: the external API implementation, or the application, can
+ * express the memory types it is interested in by filling in the \ref
+ * mem_type field accordingly. On successful output, the memory type
+ * that fits best the request and that was used is updated in the \ref
+ * VABufferInfo data structure. If none of the supplied memory types
+ * is supported, then a \ref VA_STATUS_ERROR_UNSUPPORTED_MEMORY_TYPE
+ * error is returned.
+ *
+ * The \ref VABufferInfo data is valid until vaReleaseBufferHandle()
+ * is called. Besides, no additional operation is allowed on any of
+ * the buffer parent object until vaReleaseBufferHandle() is called.
+ * e.g. decoding into a VA surface backed with the supplied VA buffer
+ * object \ref buf_id would fail with a \ref VA_STATUS_ERROR_SURFACE_BUSY
+ * error.
+ *
+ * Possible errors:
+ * - \ref VA_STATUS_ERROR_UNIMPLEMENTED: the VA driver implementation
+ *   does not support this interface
+ * - \ref VA_STATUS_ERROR_INVALID_DISPLAY: an invalid display was supplied
+ * - \ref VA_STATUS_ERROR_INVALID_BUFFER: an invalid buffer was supplied
+ * - \ref VA_STATUS_ERROR_UNSUPPORTED_BUFFERTYPE: the implementation
+ *   does not support exporting buffers of the specified type
+ * - \ref VA_STATUS_ERROR_UNSUPPORTED_MEMORY_TYPE: none of the requested
+ *   memory types in \ref VABufferInfo.mem_type was supported
+ *
+ * @param[in] dpy               the VA display
+ * @param[in] buf_id            the VA buffer
+ * @param[in,out] buf_info      the associated VA buffer information
+ * @return VA_STATUS_SUCCESS if successful
+ */
+VAStatus
+vaAcquireBufferHandle(VADisplay dpy, VABufferID buf_id, VABufferInfo *buf_info);
+
+/**
+ * \brief Releases buffer after usage from external API
+ *
+ * Unlocks the VA buffer object \ref buf_id from external API usage like
+ * EGL or OpenCL (OCL). This function is a synchronization point. This
+ * means that any pending operation is guaranteed to be completed
+ * prior to returning from the function.
+ *
+ * The \ref VABufferInfo argument shall point to the original data
+ * structure that was obtained from vaAcquireBufferHandle(), unaltered.
+ * This is necessary so that the VA driver implementation could
+ * deallocate any resources that were needed.
+ *
+ * In any case, returning from this function invalidates any contents
+ * in \ref VABufferInfo. i.e. the underlyng buffer handle is no longer
+ * valid. Therefore, VA driver implementations are free to reset this
+ * data structure to safe defaults.
+ *
+ * Possible errors:
+ * - \ref VA_STATUS_ERROR_UNIMPLEMENTED: the VA driver implementation
+ *   does not support this interface
+ * - \ref VA_STATUS_ERROR_INVALID_DISPLAY: an invalid display was supplied
+ * - \ref VA_STATUS_ERROR_INVALID_BUFFER: an invalid buffer was supplied
+ * - \ref VA_STATUS_ERROR_UNSUPPORTED_BUFFERTYPE: the implementation
+ *   does not support exporting buffers of the specified type
+ *
+ * @param[in] dpy               the VA display
+ * @param[in] buf_id            the VA buffer
+ * @return VA_STATUS_SUCCESS if successful
+ */
+VAStatus
+vaReleaseBufferHandle(VADisplay dpy, VABufferID buf_id);
+
+/*
+Render (Decode) Pictures
+
+A picture represents either a frame or a field.
+
+The Begin/Render/End sequence sends the decode buffers to the server
+*/
+
+/**
+ * Get ready to decode a picture to a target surface
+ */
+VAStatus vaBeginPicture (
+    VADisplay dpy,
+    VAContextID context,
+    VASurfaceID render_target
+);
+
+/**
+ * Send decode buffers to the server.
+ * Buffers are automatically destroyed afterwards
+ */
+VAStatus vaRenderPicture (
+    VADisplay dpy,
+    VAContextID context,
+    VABufferID *buffers,
+    int num_buffers
+);
+
+/**
+ * Make the end of rendering for a picture. 
+ * The server should start processing all pending operations for this 
+ * surface. This call is non-blocking. The client can start another 
+ * Begin/Render/End sequence on a different render target.
+ */
+VAStatus vaEndPicture (
+    VADisplay dpy,
+    VAContextID context
+);
+
+/*
+
+Synchronization 
+
+*/
+
+/**
+ * This function blocks until all pending operations on the render target
+ * have been completed.  Upon return it is safe to use the render target for a 
+ * different picture. 
+ */
+VAStatus vaSyncSurface (
+    VADisplay dpy,
+    VASurfaceID render_target
+);
+
+typedef enum
+{
+    VASurfaceRendering	= 1, /* Rendering in progress */ 
+    VASurfaceDisplaying	= 2, /* Displaying in progress (not safe to render into it) */ 
+                             /* this status is useful if surface is used as the source */
+                             /* of an overlay */
+    VASurfaceReady	= 4, /* not being rendered or displayed */
+    VASurfaceSkipped	= 8  /* Indicate a skipped frame during encode */
+} VASurfaceStatus;
+
+/**
+ * Find out any pending ops on the render target 
+ */
+VAStatus vaQuerySurfaceStatus (
+    VADisplay dpy,
+    VASurfaceID render_target,
+    VASurfaceStatus *status	/* out */
+);
+
+typedef enum
+{
+    VADecodeSliceMissing            = 0,
+    VADecodeMBError                 = 1,
+} VADecodeErrorType;
+
+/**
+ * Client calls vaQuerySurfaceError with VA_STATUS_ERROR_DECODING_ERROR, server side returns
+ * an array of structure VASurfaceDecodeMBErrors, and the array is terminated by setting status=-1
+*/
+typedef struct _VASurfaceDecodeMBErrors
+{
+    int status; /* 1 if hardware has returned detailed info below, -1 means this record is invalid */
+    unsigned int start_mb; /* start mb address with errors */
+    unsigned int end_mb;  /* end mb address with errors */
+    VADecodeErrorType decode_error_type;
+} VASurfaceDecodeMBErrors;
+
+/**
+ * After the application gets VA_STATUS_ERROR_DECODING_ERROR after calling vaSyncSurface(),
+ * it can call vaQuerySurfaceError to find out further details on the particular error.
+ * VA_STATUS_ERROR_DECODING_ERROR should be passed in as "error_status",
+ * upon the return, error_info will point to an array of _VASurfaceDecodeMBErrors structure,
+ * which is allocated and filled by libVA with detailed information on the missing or error macroblocks.
+ * The array is terminated if "status==-1" is detected.
+ */
+VAStatus vaQuerySurfaceError(
+    VADisplay dpy,
+    VASurfaceID surface,
+    VAStatus error_status,
+    void **error_info
+);
+
+/**
+ * Images and Subpictures
+ * VAImage is used to either get the surface data to client memory, or 
+ * to copy image data in client memory to a surface. 
+ * Both images, subpictures and surfaces follow the same 2D coordinate system where origin 
+ * is at the upper left corner with positive X to the right and positive Y down
+ */
+#define VA_FOURCC(ch0, ch1, ch2, ch3) \
+    ((unsigned long)(unsigned char) (ch0) | ((unsigned long)(unsigned char) (ch1) << 8) | \
+    ((unsigned long)(unsigned char) (ch2) << 16) | ((unsigned long)(unsigned char) (ch3) << 24 ))
+
+/* 
+ * Pre-defined fourcc codes
+ */
+#define VA_FOURCC_NV12		0x3231564E
+#define VA_FOURCC_AI44		0x34344149
+#define VA_FOURCC_RGBA		0x41424752
+#define VA_FOURCC_RGBX		0x58424752
+#define VA_FOURCC_BGRA		0x41524742
+#define VA_FOURCC_BGRX		0x58524742
+#define VA_FOURCC_ARGB		0x42475241
+#define VA_FOURCC_XRGB		0x42475258
+#define VA_FOURCC_ABGR          0x52474241
+#define VA_FOURCC_XBGR          0x52474258
+#define VA_FOURCC_UYVY          0x59565955
+#define VA_FOURCC_YUY2          0x32595559
+#define VA_FOURCC_AYUV          0x56555941
+#define VA_FOURCC_NV11          0x3131564e
+#define VA_FOURCC_YV12          0x32315659
+#define VA_FOURCC_P208          0x38303250
+#define VA_FOURCC_IYUV          0x56555949
+#define VA_FOURCC_YV24          0x34325659
+#define VA_FOURCC_YV32          0x32335659
+#define VA_FOURCC_Y800          0x30303859
+#define VA_FOURCC_IMC3          0x33434D49
+#define VA_FOURCC_411P          0x50313134
+#define VA_FOURCC_422H          0x48323234
+#define VA_FOURCC_422V          0x56323234
+#define VA_FOURCC_444P          0x50343434
+#define VA_FOURCC_RGBP          0x50424752
+#define VA_FOURCC_BGRP          0x50524742
+#define VA_FOURCC_411R          0x52313134 /* rotated 411P */
+
+/* byte order */
+#define VA_LSB_FIRST		1
+#define VA_MSB_FIRST		2
+
+typedef struct _VAImageFormat
+{
+    unsigned int	fourcc;
+    unsigned int	byte_order; /* VA_LSB_FIRST, VA_MSB_FIRST */
+    unsigned int	bits_per_pixel;
+    /* for RGB formats */
+    unsigned int	depth; /* significant bits per pixel */
+    unsigned int	red_mask;
+    unsigned int	green_mask;
+    unsigned int	blue_mask;
+    unsigned int	alpha_mask;
+} VAImageFormat;
+
+typedef VAGenericID VAImageID;
+
+typedef struct _VAImage
+{
+    VAImageID		image_id; /* uniquely identify this image */
+    VAImageFormat	format;
+    VABufferID		buf;	/* image data buffer */
+    /*
+     * Image data will be stored in a buffer of type VAImageBufferType to facilitate
+     * data store on the server side for optimal performance. The buffer will be 
+     * created by the CreateImage function, and proper storage allocated based on the image
+     * size and format. This buffer is managed by the library implementation, and 
+     * accessed by the client through the buffer Map/Unmap functions.
+     */
+    unsigned short	width; 
+    unsigned short	height;
+    unsigned int	data_size;
+    unsigned int	num_planes;	/* can not be greater than 3 */
+    /* 
+     * An array indicating the scanline pitch in bytes for each plane.
+     * Each plane may have a different pitch. Maximum 3 planes for planar formats
+     */
+    unsigned int	pitches[3];
+    /* 
+     * An array indicating the byte offset from the beginning of the image data 
+     * to the start of each plane.
+     */
+    unsigned int	offsets[3];
+
+    /* The following fields are only needed for paletted formats */
+    int num_palette_entries;   /* set to zero for non-palette images */
+    /* 
+     * Each component is one byte and entry_bytes indicates the number of components in 
+     * each entry (eg. 3 for YUV palette entries). set to zero for non-palette images   
+     */
+    int entry_bytes; 
+    /*
+     * An array of ascii characters describing the order of the components within the bytes.
+     * Only entry_bytes characters of the string are used.
+     */
+    char component_order[4];
+} VAImage;
+
+/** Get maximum number of image formats supported by the implementation */
+int vaMaxNumImageFormats (
+    VADisplay dpy
+);
+
+/**
+ * Query supported image formats 
+ * The caller must provide a "format_list" array that can hold at
+ * least vaMaxNumImageFormats() entries. The actual number of formats
+ * returned in "format_list" is returned in "num_formats".
+ */
+VAStatus vaQueryImageFormats (
+    VADisplay dpy,
+    VAImageFormat *format_list,	/* out */
+    int *num_formats		/* out */
+);
+
+/**
+ * Create a VAImage structure
+ * The width and height fields returned in the VAImage structure may get 
+ * enlarged for some YUV formats. Upon return from this function, 
+ * image->buf has been created and proper storage allocated by the library. 
+ * The client can access the image through the Map/Unmap calls.
+ */
+VAStatus vaCreateImage (
+    VADisplay dpy,
+    VAImageFormat *format,
+    int width,
+    int height,
+    VAImage *image	/* out */
+);
+
+/**
+ * Should call DestroyImage before destroying the surface it is bound to
+ */
+VAStatus vaDestroyImage (
+    VADisplay dpy,
+    VAImageID image
+);
+
+VAStatus vaSetImagePalette (
+    VADisplay dpy,
+    VAImageID image,
+    /* 
+     * pointer to an array holding the palette data.  The size of the array is 
+     * num_palette_entries * entry_bytes in size.  The order of the components 
+     * in the palette is described by the component_order in VAImage struct    
+     */
+    unsigned char *palette 
+);
+
+/**
+ * Retrive surface data into a VAImage
+ * Image must be in a format supported by the implementation
+ */
+VAStatus vaGetImage (
+    VADisplay dpy,
+    VASurfaceID surface,
+    int x,	/* coordinates of the upper left source pixel */
+    int y,
+    unsigned int width, /* width and height of the region */
+    unsigned int height,
+    VAImageID image
+);
+
+/**
+ * Copy data from a VAImage to a surface
+ * Image must be in a format supported by the implementation
+ * Returns a VA_STATUS_ERROR_SURFACE_BUSY if the surface
+ * shouldn't be rendered into when this is called
+ */
+VAStatus vaPutImage (
+    VADisplay dpy,
+    VASurfaceID surface,
+    VAImageID image,
+    int src_x,
+    int src_y,
+    unsigned int src_width,
+    unsigned int src_height,
+    int dest_x,
+    int dest_y,
+    unsigned int dest_width,
+    unsigned int dest_height
+);
+
+/**
+ * Derive an VAImage from an existing surface.
+ * This interface will derive a VAImage and corresponding image buffer from
+ * an existing VA Surface. The image buffer can then be mapped/unmapped for
+ * direct CPU access. This operation is only possible on implementations with
+ * direct rendering capabilities and internal surface formats that can be
+ * represented with a VAImage. When the operation is not possible this interface
+ * will return VA_STATUS_ERROR_OPERATION_FAILED. Clients should then fall back
+ * to using vaCreateImage + vaPutImage to accomplish the same task in an
+ * indirect manner.
+ *
+ * Implementations should only return success when the resulting image buffer
+ * would be useable with vaMap/Unmap.
+ *
+ * When directly accessing a surface special care must be taken to insure
+ * proper synchronization with the graphics hardware. Clients should call
+ * vaQuerySurfaceStatus to insure that a surface is not the target of concurrent
+ * rendering or currently being displayed by an overlay.
+ *
+ * Additionally nothing about the contents of a surface should be assumed
+ * following a vaPutSurface. Implementations are free to modify the surface for
+ * scaling or subpicture blending within a call to vaPutImage.
+ *
+ * Calls to vaPutImage or vaGetImage using the same surface from which the image
+ * has been derived will return VA_STATUS_ERROR_SURFACE_BUSY. vaPutImage or
+ * vaGetImage with other surfaces is supported.
+ *
+ * An image created with vaDeriveImage should be freed with vaDestroyImage. The
+ * image and image buffer structures will be destroyed; however, the underlying
+ * surface will remain unchanged until freed with vaDestroySurfaces.
+ */
+VAStatus vaDeriveImage (
+    VADisplay dpy,
+    VASurfaceID surface,
+    VAImage *image	/* out */
+);
+
+/**
+ * Subpictures 
+ * Subpicture is a special type of image that can be blended 
+ * with a surface during vaPutSurface(). Subpicture can be used to render
+ * DVD sub-titles or closed captioning text etc.  
+ */
+
+typedef VAGenericID VASubpictureID;
+
+/** Get maximum number of subpicture formats supported by the implementation */
+int vaMaxNumSubpictureFormats (
+    VADisplay dpy
+);
+
+/** flags for subpictures */
+#define VA_SUBPICTURE_CHROMA_KEYING			0x0001
+#define VA_SUBPICTURE_GLOBAL_ALPHA			0x0002
+#define VA_SUBPICTURE_DESTINATION_IS_SCREEN_COORD	0x0004
+/**
+ * Query supported subpicture formats 
+ * The caller must provide a "format_list" array that can hold at
+ * least vaMaxNumSubpictureFormats() entries. The flags arrary holds the flag 
+ * for each format to indicate additional capabilities for that format. The actual 
+ * number of formats returned in "format_list" is returned in "num_formats".
+ *  flags: returned value to indicate addtional capabilities
+ *         VA_SUBPICTURE_CHROMA_KEYING - supports chroma-keying
+ *         VA_SUBPICTURE_GLOBAL_ALPHA - supports global alpha
+ * 	   VA_SUBPICTURE_DESTINATION_IS_SCREEN_COORD - supports unscaled screen relative subpictures for On Screen Display
+ */
+
+VAStatus vaQuerySubpictureFormats (
+    VADisplay dpy,
+    VAImageFormat *format_list,	/* out */
+    unsigned int *flags,	/* out */
+    unsigned int *num_formats	/* out */
+);
+
+/**
+ * Subpictures are created with an image associated. 
+ */
+VAStatus vaCreateSubpicture (
+    VADisplay dpy,
+    VAImageID image,
+    VASubpictureID *subpicture	/* out */
+);
+
+/**
+ * Destroy the subpicture before destroying the image it is assocated to
+ */
+VAStatus vaDestroySubpicture (
+    VADisplay dpy,
+    VASubpictureID subpicture
+);
+
+/**
+ * Bind an image to the subpicture. This image will now be associated with 
+ * the subpicture instead of the one at creation.
+ */
+VAStatus vaSetSubpictureImage (
+    VADisplay dpy,
+    VASubpictureID subpicture,
+    VAImageID image
+);
+
+/**
+ * If chromakey is enabled, then the area where the source value falls within
+ * the chromakey [min, max] range is transparent
+ * The chromakey component format is the following:
+ *  For RGB: [0:7] Red [8:15] Blue [16:23] Green   
+ *  For YUV: [0:7] V [8:15] U [16:23] Y
+ * The chromakey mask can be used to mask out certain components for chromakey
+ * comparision
+ */
+VAStatus vaSetSubpictureChromakey (
+    VADisplay dpy,
+    VASubpictureID subpicture,
+    unsigned int chromakey_min,
+    unsigned int chromakey_max,
+    unsigned int chromakey_mask
+);
+
+/**
+ * Global alpha value is between 0 and 1. A value of 1 means fully opaque and 
+ * a value of 0 means fully transparent. If per-pixel alpha is also specified then
+ * the overall alpha is per-pixel alpha multiplied by the global alpha
+ */
+VAStatus vaSetSubpictureGlobalAlpha (
+    VADisplay dpy,
+    VASubpictureID subpicture,
+    float global_alpha 
+);
+
+/**
+ * vaAssociateSubpicture associates the subpicture with target_surfaces.
+ * It defines the region mapping between the subpicture and the target  
+ * surfaces through source and destination rectangles (with the same width and height).
+ * Both will be displayed at the next call to vaPutSurface.  Additional
+ * associations before the call to vaPutSurface simply overrides the association.
+ */
+VAStatus vaAssociateSubpicture (
+    VADisplay dpy,
+    VASubpictureID subpicture,
+    VASurfaceID *target_surfaces,
+    int num_surfaces,
+    short src_x, /* upper left offset in subpicture */
+    short src_y,
+    unsigned short src_width,
+    unsigned short src_height,
+    short dest_x, /* upper left offset in surface */
+    short dest_y,
+    unsigned short dest_width,
+    unsigned short dest_height,
+    /*
+     * whether to enable chroma-keying, global-alpha, or screen relative mode
+     * see VA_SUBPICTURE_XXX values
+     */
+    unsigned int flags
+);
+
+/**
+ * vaDeassociateSubpicture removes the association of the subpicture with target_surfaces.
+ */
+VAStatus vaDeassociateSubpicture (
+    VADisplay dpy,
+    VASubpictureID subpicture,
+    VASurfaceID *target_surfaces,
+    int num_surfaces
+);
+
+typedef struct _VARectangle
+{
+    short x;
+    short y;
+    unsigned short width;
+    unsigned short height;
+} VARectangle;
+
+/**
+ * Display attributes
+ * Display attributes are used to control things such as contrast, hue, saturation,
+ * brightness etc. in the rendering process.  The application can query what
+ * attributes are supported by the driver, and then set the appropriate attributes
+ * before calling vaPutSurface()
+ */
+/* PowerVR IEP Lite attributes */
+typedef enum
+{
+    VADISPLAYATTRIB_BLE_OFF              = 0x00,
+    VADISPLAYATTRIB_BLE_LOW,
+    VADISPLAYATTRIB_BLE_MEDIUM,
+    VADISPLAYATTRIB_BLE_HIGH,
+    VADISPLAYATTRIB_BLE_NONE,
+} VADisplayAttribBLEMode;
+
+/** attribute value for VADisplayAttribRotation   */
+#define VA_ROTATION_NONE        0x00000000
+#define VA_ROTATION_90          0x00000001
+#define VA_ROTATION_180         0x00000002
+#define VA_ROTATION_270         0x00000003
+
+/** attribute value for VADisplayAttribOutOfLoopDeblock */
+#define VA_OOL_DEBLOCKING_FALSE 0x00000000
+#define VA_OOL_DEBLOCKING_TRUE  0x00000001
+
+/** Render mode */
+#define VA_RENDER_MODE_UNDEFINED           0
+#define VA_RENDER_MODE_LOCAL_OVERLAY       1
+#define VA_RENDER_MODE_LOCAL_GPU           2
+#define VA_RENDER_MODE_EXTERNAL_OVERLAY    4
+#define VA_RENDER_MODE_EXTERNAL_GPU        8
+
+/** Render device */
+#define VA_RENDER_DEVICE_UNDEFINED  0
+#define VA_RENDER_DEVICE_LOCAL      1
+#define VA_RENDER_DEVICE_EXTERNAL   2
+
+/** Currently defined display attribute types */
+typedef enum
+{
+    VADisplayAttribBrightness		= 0,
+    VADisplayAttribContrast		= 1,
+    VADisplayAttribHue			= 2,
+    VADisplayAttribSaturation		= 3,
+    /* client can specifiy a background color for the target window
+     * the new feature of video conference,
+     * the uncovered area of the surface is filled by this color
+     * also it will blend with the decoded video color
+     */
+    VADisplayAttribBackgroundColor      = 4,
+    /*
+     * this is a gettable only attribute. For some implementations that use the
+     * hardware overlay, after PutSurface is called, the surface can not be    
+     * re-used until after the subsequent PutSurface call. If this is the case 
+     * then the value for this attribute will be set to 1 so that the client   
+     * will not attempt to re-use the surface right after returning from a call
+     * to PutSurface.
+     *
+     * Don't use it, use flag VASurfaceDisplaying of vaQuerySurfaceStatus since
+     * driver may use overlay or GPU alternatively
+     */
+    VADisplayAttribDirectSurface       = 5,
+    VADisplayAttribRotation            = 6,	
+    VADisplayAttribOutofLoopDeblock    = 7,
+
+    /* PowerVR IEP Lite specific attributes */
+    VADisplayAttribBLEBlackMode        = 8,
+    VADisplayAttribBLEWhiteMode        = 9,
+    VADisplayAttribBlueStretch         = 10,
+    VADisplayAttribSkinColorCorrection = 11,
+    /*
+     * For type VADisplayAttribCSCMatrix, "value" field is a pointer to the color
+     * conversion matrix. Each element in the matrix is float-point
+     */
+    VADisplayAttribCSCMatrix           = 12,
+    /* specify the constant color used to blend with video surface
+     * Cd = Cv*Cc*Ac + Cb *(1 - Ac) C means the constant RGB
+     *      d: the final color to overwrite into the frame buffer 
+     *      v: decoded video after color conversion, 
+     *      c: video color specified by VADisplayAttribBlendColor
+     *      b: background color of the drawable
+     */
+    VADisplayAttribBlendColor          = 13,
+    /*
+     * Indicate driver to skip painting color key or not.
+     * only applicable if the render is overlay
+     */
+    VADisplayAttribOverlayAutoPaintColorKey   = 14,
+    /*
+     * customized overlay color key, the format is RGB888
+     * [23:16] = Red, [15:08] = Green, [07:00] = Blue.
+     */
+    VADisplayAttribOverlayColorKey	= 15,
+    /*
+     * The hint for the implementation of vaPutSurface
+     * normally, the driver could use an overlay or GPU to render the surface on the screen
+     * this flag provides APP the flexibity to switch the render dynamically
+     */
+    VADisplayAttribRenderMode           = 16,
+    /*
+     * specify if vaPutSurface needs to render into specified monitors
+     * one example is that one external monitor (e.g. HDMI) is enabled, 
+     * but the window manager is not aware of it, and there is no associated drawable
+     */
+    VADisplayAttribRenderDevice        = 17,
+    /*
+     * specify vaPutSurface render area if there is no drawable on the monitor
+     */
+    VADisplayAttribRenderRect          = 18,
+} VADisplayAttribType;
+
+/* flags for VADisplayAttribute */
+#define VA_DISPLAY_ATTRIB_NOT_SUPPORTED	0x0000
+#define VA_DISPLAY_ATTRIB_GETTABLE	0x0001
+#define VA_DISPLAY_ATTRIB_SETTABLE	0x0002
+
+typedef struct _VADisplayAttribute
+{
+    VADisplayAttribType type;
+    int min_value;
+    int max_value;
+    int value;	/* used by the set/get attribute functions */
+/* flags can be VA_DISPLAY_ATTRIB_GETTABLE or VA_DISPLAY_ATTRIB_SETTABLE or OR'd together */
+    unsigned int flags;
+} VADisplayAttribute;
+
+/** Get maximum number of display attributs supported by the implementation */
+int vaMaxNumDisplayAttributes (
+    VADisplay dpy
+);
+
+/**
+ * Query display attributes 
+ * The caller must provide a "attr_list" array that can hold at
+ * least vaMaxNumDisplayAttributes() entries. The actual number of attributes
+ * returned in "attr_list" is returned in "num_attributes".
+ */
+VAStatus vaQueryDisplayAttributes (
+    VADisplay dpy,
+    VADisplayAttribute *attr_list,	/* out */
+    int *num_attributes			/* out */
+);
+
+/**
+ * Get display attributes 
+ * This function returns the current attribute values in "attr_list".
+ * Only attributes returned with VA_DISPLAY_ATTRIB_GETTABLE set in the "flags" field
+ * from vaQueryDisplayAttributes() can have their values retrieved.  
+ */
+VAStatus vaGetDisplayAttributes (
+    VADisplay dpy,
+    VADisplayAttribute *attr_list,	/* in/out */
+    int num_attributes
+);
+
+/**
+ * Set display attributes 
+ * Only attributes returned with VA_DISPLAY_ATTRIB_SETTABLE set in the "flags" field
+ * from vaQueryDisplayAttributes() can be set.  If the attribute is not settable or 
+ * the value is out of range, the function returns VA_STATUS_ERROR_ATTR_NOT_SUPPORTED
+ */
+VAStatus vaSetDisplayAttributes (
+    VADisplay dpy,
+    VADisplayAttribute *attr_list,
+    int num_attributes
+);
+
+/****************************
+ * HEVC data structures
+ ****************************/
+/** 
+ * \brief Description of picture properties of those in DPB surfaces.
+ *
+ * If only progressive scan is supported, each surface contains one whole 
+ * frame picture.
+ * Otherwise, each surface contains two fields of whole picture.
+ * In this case, two entries of ReferenceFrames[] may share same picture_id
+ * value.
+ */
+typedef struct _VAPictureHEVC
+{
+    /** \brief reconstructed picture buffer surface index 
+     * invalid when taking value VA_INVALID_SURFACE.
+     */
+    VASurfaceID             picture_id;
+    /** \brief picture order count. 
+     * in HEVC, POCs for top and bottom fields of same picture should
+     * take different values.
+     */
+    int32_t                 pic_order_cnt;
+    /* described below */
+    uint32_t                flags;
+} VAPictureHEVC;
+
+/* flags in VAPictureHEVC could be OR of the following */
+#define VA_PICTURE_HEVC_INVALID                 0x00000001
+/** \brief indication of interlace scan picture. 
+ * should take same value for all the pictures in sequence.
+ */ 
+#define VA_PICTURE_HEVC_FIELD_PIC               0x00000002
+/** \brief polarity of the field picture.
+ * top field takes even lines of buffer surface.
+ * bottom field takes odd lines of buffer surface.
+ */
+#define VA_PICTURE_HEVC_BOTTOM_FIELD            0x00000004
+/** \brief Long term reference picture */
+#define VA_PICTURE_HEVC_LONG_TERM_REFERENCE     0x00000008
+/**
+ * VA_PICTURE_HEVC_RPS_ST_CURR_BEFORE, VA_PICTURE_HEVC_RPS_ST_CURR_AFTER
+ * and VA_PICTURE_HEVC_RPS_LT_CURR of any picture in ReferenceFrames[] should 
+ * be exclusive. No more than one of them can be set for any picture.
+ * Sum of NumPocStCurrBefore, NumPocStCurrAfter and NumPocLtCurr
+ * equals NumPocTotalCurr, which should be equal to or smaller than 8.
+ * Application should provide valid values for both short format and long format.
+ * The pictures in DPB with any of these three flags turned on are referred by
+ * the current picture.
+ */
+/** \brief RefPicSetStCurrBefore of HEVC spec variable 
+ * Number of ReferenceFrames[] entries with this bit set equals 
+ * NumPocStCurrBefore.
+ */
+#define VA_PICTURE_HEVC_RPS_ST_CURR_BEFORE      0x00000010
+/** \brief RefPicSetStCurrAfter of HEVC spec variable
+ * Number of ReferenceFrames[] entries with this bit set equals 
+ * NumPocStCurrAfter.
+ */
+#define VA_PICTURE_HEVC_RPS_ST_CURR_AFTER       0x00000020
+/** \brief RefPicSetLtCurr of HEVC spec variable
+ * Number of ReferenceFrames[] entries with this bit set equals 
+ * NumPocLtCurr.
+ */
+#define VA_PICTURE_HEVC_RPS_LT_CURR             0x00000040
+
+#include <va/va_dec_hevc.h>
+#include <va/va_dec_jpeg.h>
+#include <va/va_dec_vp8.h>
+#include <va/va_dec_vp9.h>
+#include <va/va_enc_hevc.h>
+#include <va/va_enc_h264.h>
+#include <va/va_enc_jpeg.h>
+#include <va/va_enc_mpeg2.h>
+#include <va/va_enc_vp8.h>
+#include <va/va_vpp.h>
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _VA_H_ */
--- /dev/null
+++ src/gallium/state_trackers/va/va/va_backend.h
@@ -0,0 +1,562 @@
+/*
+ * Copyright (c) 2007 Intel Corporation. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+ * Video Decode Acceleration -Backend API
+ */
+
+#ifndef _VA_BACKEND_H_
+#define _VA_BACKEND_H_
+
+#include <va/va.h>
+#include <linux/videodev2.h>
+
+typedef struct VADriverContext *VADriverContextP;
+typedef struct VADisplayContext *VADisplayContextP;
+
+/** \brief VA display types. */
+enum {
+    /** \brief Mask to major identifier for VA display type. */
+    VA_DISPLAY_MAJOR_MASK = 0xf0,
+
+    /** \brief VA/X11 API is used, through vaGetDisplay() entry-point. */
+    VA_DISPLAY_X11      = 0x10,
+    /** \brief VA/GLX API is used, through vaGetDisplayGLX() entry-point. */
+    VA_DISPLAY_GLX      = (VA_DISPLAY_X11 | (1 << 0)),
+    /** \brief VA/Android API is used, through vaGetDisplay() entry-point. */
+    VA_DISPLAY_ANDROID  = 0x20,
+    /** \brief VA/DRM API is used, through vaGetDisplayDRM() entry-point. */
+    VA_DISPLAY_DRM      = 0x30,
+    /** \brief VA/DRM API is used, with a render-node device path */
+    VA_DISPLAY_DRM_RENDERNODES = (VA_DISPLAY_DRM | (1 << 0)),
+    /** \brief VA/Wayland API is used, through vaGetDisplayWl() entry-point. */
+    VA_DISPLAY_WAYLAND  = 0x40,
+};
+
+struct VADriverVTable
+{
+	VAStatus (*vaTerminate) ( VADriverContextP ctx );
+
+	VAStatus (*vaQueryConfigProfiles) (
+		VADriverContextP ctx,
+		VAProfile *profile_list,	/* out */
+		int *num_profiles			/* out */
+	);
+
+	VAStatus (*vaQueryConfigEntrypoints) (
+		VADriverContextP ctx,
+		VAProfile profile,
+		VAEntrypoint  *entrypoint_list,	/* out */
+		int *num_entrypoints			/* out */
+	);
+
+	VAStatus (*vaGetConfigAttributes) (
+		VADriverContextP ctx,
+		VAProfile profile,
+		VAEntrypoint entrypoint,
+		VAConfigAttrib *attrib_list,	/* in/out */
+		int num_attribs
+	);
+
+	VAStatus (*vaCreateConfig) (
+		VADriverContextP ctx,
+		VAProfile profile, 
+		VAEntrypoint entrypoint, 
+		VAConfigAttrib *attrib_list,
+		int num_attribs,
+		VAConfigID *config_id		/* out */
+	);
+
+	VAStatus (*vaDestroyConfig) (
+		VADriverContextP ctx,
+		VAConfigID config_id
+	);
+
+	VAStatus (*vaQueryConfigAttributes) (
+		VADriverContextP ctx,
+		VAConfigID config_id, 
+		VAProfile *profile,		/* out */
+		VAEntrypoint *entrypoint, 	/* out */
+		VAConfigAttrib *attrib_list,	/* out */
+		int *num_attribs		/* out */
+	);
+
+	VAStatus (*vaCreateSurfaces) (
+		VADriverContextP ctx,
+		int width,
+		int height,
+		int format,
+		int num_surfaces,
+		VASurfaceID *surfaces		/* out */
+	);
+
+	VAStatus (*vaDestroySurfaces) (
+		VADriverContextP ctx,
+		VASurfaceID *surface_list,
+		int num_surfaces
+	);
+
+	VAStatus (*vaCreateContext) (
+		VADriverContextP ctx,
+		VAConfigID config_id,
+		int picture_width,
+		int picture_height,
+		int flag,
+		VASurfaceID *render_targets,
+		int num_render_targets,
+		VAContextID *context		/* out */
+	);
+
+	VAStatus (*vaDestroyContext) (
+		VADriverContextP ctx,
+		VAContextID context
+	);
+
+	VAStatus (*vaCreateBuffer) (
+		VADriverContextP ctx,
+		VAContextID context,		/* in */
+		VABufferType type,		/* in */
+		unsigned int size,		/* in */
+		unsigned int num_elements,	/* in */
+		void *data,			/* in */
+		VABufferID *buf_id		/* out */
+	);
+
+	VAStatus (*vaBufferSetNumElements) (
+		VADriverContextP ctx,
+		VABufferID buf_id,	/* in */
+		unsigned int num_elements	/* in */
+	);
+
+	VAStatus (*vaMapBuffer) (
+		VADriverContextP ctx,
+		VABufferID buf_id,	/* in */
+		void **pbuf         /* out */
+	);
+
+	VAStatus (*vaUnmapBuffer) (
+		VADriverContextP ctx,
+		VABufferID buf_id	/* in */
+	);
+
+	VAStatus (*vaDestroyBuffer) (
+		VADriverContextP ctx,
+		VABufferID buffer_id
+	);
+
+	VAStatus (*vaBeginPicture) (
+		VADriverContextP ctx,
+		VAContextID context,
+		VASurfaceID render_target
+	);
+
+	VAStatus (*vaRenderPicture) (
+		VADriverContextP ctx,
+		VAContextID context,
+		VABufferID *buffers,
+		int num_buffers
+	);
+
+	VAStatus (*vaEndPicture) (
+		VADriverContextP ctx,
+		VAContextID context
+	);
+
+	VAStatus (*vaSyncSurface) (
+		VADriverContextP ctx,
+		VASurfaceID render_target
+	);
+
+	VAStatus (*vaQuerySurfaceStatus) (
+		VADriverContextP ctx,
+		VASurfaceID render_target,
+		VASurfaceStatus *status	/* out */
+	);
+
+	VAStatus (*vaQuerySurfaceError) (
+		VADriverContextP ctx,
+		VASurfaceID render_target,
+                VAStatus error_status,
+                void **error_info /*out*/
+	);
+
+	VAStatus (*vaPutSurface) (
+    		VADriverContextP ctx,
+		VASurfaceID surface,
+		void* draw, /* Drawable of window system */
+		short srcx,
+		short srcy,
+		unsigned short srcw,
+		unsigned short srch,
+		short destx,
+		short desty,
+		unsigned short destw,
+		unsigned short desth,
+		VARectangle *cliprects, /* client supplied clip list */
+		unsigned int number_cliprects, /* number of clip rects in the clip list */
+		unsigned int flags /* de-interlacing flags */
+	);
+
+	VAStatus (*vaQueryImageFormats) (
+		VADriverContextP ctx,
+		VAImageFormat *format_list,        /* out */
+		int *num_formats           /* out */
+	);
+
+	VAStatus (*vaCreateImage) (
+		VADriverContextP ctx,
+		VAImageFormat *format,
+		int width,
+		int height,
+		VAImage *image     /* out */
+	);
+
+	VAStatus (*vaDeriveImage) (
+		VADriverContextP ctx,
+		VASurfaceID surface,
+		VAImage *image     /* out */
+	);
+
+	VAStatus (*vaDestroyImage) (
+		VADriverContextP ctx,
+		VAImageID image
+	);
+	
+	VAStatus (*vaSetImagePalette) (
+	        VADriverContextP ctx,
+	        VAImageID image,
+	        /*
+                 * pointer to an array holding the palette data.  The size of the array is
+                 * num_palette_entries * entry_bytes in size.  The order of the components
+                 * in the palette is described by the component_order in VAImage struct
+                 */
+                unsigned char *palette
+	);
+	
+	VAStatus (*vaGetImage) (
+		VADriverContextP ctx,
+		VASurfaceID surface,
+		int x,     /* coordinates of the upper left source pixel */
+		int y,
+		unsigned int width, /* width and height of the region */
+		unsigned int height,
+		VAImageID image
+	);
+
+	VAStatus (*vaPutImage) (
+		VADriverContextP ctx,
+		VASurfaceID surface,
+		VAImageID image,
+		int src_x,
+		int src_y,
+		unsigned int src_width,
+		unsigned int src_height,
+		int dest_x,
+		int dest_y,
+		unsigned int dest_width,
+		unsigned int dest_height
+	);
+
+	VAStatus (*vaQuerySubpictureFormats) (
+		VADriverContextP ctx,
+		VAImageFormat *format_list,        /* out */
+		unsigned int *flags,       /* out */
+		unsigned int *num_formats  /* out */
+	);
+
+	VAStatus (*vaCreateSubpicture) (
+		VADriverContextP ctx,
+		VAImageID image,
+		VASubpictureID *subpicture   /* out */
+	);
+
+	VAStatus (*vaDestroySubpicture) (
+		VADriverContextP ctx,
+		VASubpictureID subpicture
+	);
+
+        VAStatus (*vaSetSubpictureImage) (
+                VADriverContextP ctx,
+                VASubpictureID subpicture,
+                VAImageID image
+        );
+
+	VAStatus (*vaSetSubpictureChromakey) (
+		VADriverContextP ctx,
+		VASubpictureID subpicture,
+		unsigned int chromakey_min,
+		unsigned int chromakey_max,
+		unsigned int chromakey_mask
+	);
+
+	VAStatus (*vaSetSubpictureGlobalAlpha) (
+		VADriverContextP ctx,
+		VASubpictureID subpicture,
+		float global_alpha 
+	);
+
+	VAStatus (*vaAssociateSubpicture) (
+		VADriverContextP ctx,
+		VASubpictureID subpicture,
+		VASurfaceID *target_surfaces,
+		int num_surfaces,
+		short src_x, /* upper left offset in subpicture */
+		short src_y,
+		unsigned short src_width,
+		unsigned short src_height,
+		short dest_x, /* upper left offset in surface */
+		short dest_y,
+		unsigned short dest_width,
+		unsigned short dest_height,
+		/*
+		 * whether to enable chroma-keying or global-alpha
+		 * see VA_SUBPICTURE_XXX values
+		 */
+		unsigned int flags
+	);
+
+	VAStatus (*vaDeassociateSubpicture) (
+		VADriverContextP ctx,
+		VASubpictureID subpicture,
+		VASurfaceID *target_surfaces,
+		int num_surfaces
+	);
+
+	VAStatus (*vaQueryDisplayAttributes) (
+		VADriverContextP ctx,
+		VADisplayAttribute *attr_list,	/* out */
+		int *num_attributes		/* out */
+        );
+
+	VAStatus (*vaGetDisplayAttributes) (
+		VADriverContextP ctx,
+		VADisplayAttribute *attr_list,	/* in/out */
+		int num_attributes
+        );
+        
+        VAStatus (*vaSetDisplayAttributes) (
+		VADriverContextP ctx,
+                VADisplayAttribute *attr_list,
+                int num_attributes
+        );
+
+        /* used by va trace */        
+        VAStatus (*vaBufferInfo) (
+                   VADriverContextP ctx,      /* in */
+                   VABufferID buf_id,         /* in */
+                   VABufferType *type,        /* out */
+                   unsigned int *size,        /* out */
+                   unsigned int *num_elements /* out */
+        );
+
+        /* lock/unlock surface for external access */    
+        VAStatus (*vaLockSurface) (
+		VADriverContextP ctx,
+                VASurfaceID surface,
+                unsigned int *fourcc, /* out  for follow argument */
+                unsigned int *luma_stride,
+                unsigned int *chroma_u_stride,
+                unsigned int *chroma_v_stride,
+                unsigned int *luma_offset,
+                unsigned int *chroma_u_offset,
+                unsigned int *chroma_v_offset,
+                unsigned int *buffer_name, /* if it is not NULL, assign the low lever
+                                            * surface buffer name
+                                            */
+                void **buffer /* if it is not NULL, map the surface buffer for
+                                * CPU access
+                                */
+        );
+    
+        VAStatus (*vaUnlockSurface) (
+		VADriverContextP ctx,
+                VASurfaceID surface
+        );
+
+        /* DEPRECATED */
+        VAStatus
+        (*vaGetSurfaceAttributes)(
+            VADriverContextP    dpy,
+            VAConfigID          config,
+            VASurfaceAttrib    *attrib_list,
+            unsigned int        num_attribs
+        );
+
+        VAStatus
+        (*vaCreateSurfaces2)(
+            VADriverContextP    ctx,
+            unsigned int        format,
+            unsigned int        width,
+            unsigned int        height,
+            VASurfaceID        *surfaces,
+            unsigned int        num_surfaces,
+            VASurfaceAttrib    *attrib_list,
+            unsigned int        num_attribs
+        );
+
+        VAStatus
+        (*vaQuerySurfaceAttributes)(
+            VADriverContextP    dpy,
+            VAConfigID          config,
+            VASurfaceAttrib    *attrib_list,
+            unsigned int       *num_attribs
+        );
+
+        VAStatus
+        (*vaAcquireBufferHandle)(
+            VADriverContextP    ctx,
+            VABufferID          buf_id,         /* in */
+            VABufferInfo *      buf_info        /* in/out */
+        );
+
+        VAStatus
+        (*vaReleaseBufferHandle)(
+            VADriverContextP    ctx,
+            VABufferID          buf_id          /* in */
+        );
+};
+
+struct VADriverContext
+{
+    void *pDriverData;
+
+    /**
+     * The core VA implementation hooks.
+     *
+     * This structure is allocated from libva with calloc().
+     */
+    struct VADriverVTable *vtable;
+
+    /**
+     * The VA/GLX implementation hooks.
+     *
+     * This structure is intended for drivers that implement the
+     * VA/GLX API. The driver implementation is responsible for the
+     * allocation and deallocation of this structure.
+     */
+    struct VADriverVTableGLX *vtable_glx;
+
+    /**
+     * The VA/EGL implementation hooks.
+     *
+     * This structure is intended for drivers that implement the
+     * VA/EGL API. The driver implementation is responsible for the
+     * allocation and deallocation of this structure.
+     */
+    struct VADriverVTableEGL *vtable_egl;
+
+    /**
+     * The third-party/private implementation hooks.
+     *
+     * This structure is intended for drivers that implement the
+     * private API. The driver implementation is responsible for the
+     * allocation and deallocation of this structure.
+     */
+    void *vtable_tpi;
+
+    void *native_dpy;
+    int x11_screen;
+    int version_major;
+    int version_minor;
+    int max_profiles;
+    int max_entrypoints;
+    int max_attributes;
+    int max_image_formats;
+    int max_subpic_formats;
+    int max_display_attributes;
+    const char *str_vendor;
+
+    void *handle;			/* dlopen handle */
+
+    /**
+     * \brief DRM state.
+     *
+     * This field holds driver specific data for DRM-based
+     * drivers. This structure is allocated from libva with
+     * calloc(). Do not deallocate from within VA driver
+     * implementations.
+     *
+     * All structures shall be derived from struct drm_state. So, for
+     * instance, this field holds a dri_state structure for VA/X11
+     * drivers that use the DRM protocol.
+     */
+    void *drm_state;
+
+    void *glx;				/* opaque for GLX code */
+
+    /** \brief VA display type. */
+    unsigned long display_type;
+
+    /**
+     * The VA/Wayland implementation hooks.
+     *
+     * This structure is intended for drivers that implement the
+     * VA/Wayland API. libVA allocates this structure with calloc()
+     * and owns the resulting memory.
+     */
+    struct VADriverVTableWayland *vtable_wayland;
+
+    /**
+     * \brief The VA/VPP implementation hooks.
+     *
+     * This structure is allocated from libva with calloc().
+     */
+    struct VADriverVTableVPP *vtable_vpp;
+
+    char *override_driver_name;
+
+    unsigned long reserved[41];         /* reserve for future add-ins, decrease the subscript accordingly */
+};
+
+#define VA_DISPLAY_MAGIC 0x56414430 /* VAD0 */
+struct VADisplayContext
+{
+    int vadpy_magic;
+    
+    VADisplayContextP pNext;
+    VADriverContextP pDriverContext;
+
+    int (*vaIsValid) (
+	VADisplayContextP ctx
+    );
+
+    void (*vaDestroy) (
+	VADisplayContextP ctx
+    );
+
+    VAStatus (*vaGetDriverName) (
+	VADisplayContextP ctx,
+	char **driver_name
+    );
+
+    void *opaque; /* opaque for display extensions (e.g. GLX) */
+    void *vatrace; /* opaque for VA trace context */
+    void *vafool; /* opaque for VA fool context */
+};
+
+typedef VAStatus (*VADriverInit) (
+    VADriverContextP driver_context
+);
+
+#endif /* _VA_BACKEND_H_ */
--- /dev/null
+++ src/gallium/state_trackers/va/va/va_dec_hevc.h
@@ -0,0 +1,427 @@
+/*
+ * Copyright (c) 2014 Intel Corporation. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/**
+ * \file va_dec_hevc.h
+ * \brief The HEVC decoding API
+ *
+ * This file contains the \ref api_dec_hevc "HEVC decoding API".
+ */
+
+#ifndef VA_DEC_HEVC_H
+#define VA_DEC_HEVC_H
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \defgroup api_dec_hevc HEVC decoding API
+ *
+ * This HEVC decoding API supports Main and Main Still Picture profiles.
+ * And it supports both short slice format and long slice format.
+ *
+ * @{
+ */
+
+/**
+ * \brief HEVC Decoding Picture Parameter Buffer Structure
+ *
+ * This structure conveys picture level parameters and should be sent once
+ * per frame.
+ *
+ */
+typedef struct  _VAPictureParameterBufferHEVC
+{
+    /** \brief buffer description of decoded current picture
+     * only VA_PICTURE_HEVC_FIELD_PIC and VA_PICTURE_HEVC_BOTTOM_FIELD
+     * of "flags" fields are meaningful.
+     */
+    VAPictureHEVC           CurrPic;
+    /** \brief buffer description of reference frames in DPB */
+    VAPictureHEVC           ReferenceFrames[15];
+    /** \brief picture width, shall be integer multiple of minimum CB size. */
+    uint16_t                pic_width_in_luma_samples;
+    /** \brief picture height, shall be integer multiple of minimum CB size. */
+    uint16_t                pic_height_in_luma_samples;
+
+
+    union
+    {
+        struct
+        {
+        /** following flags have same syntax and semantic as those in HEVC spec */
+            uint32_t        chroma_format_idc                           : 2;
+            uint32_t        separate_colour_plane_flag                  : 1;
+            uint32_t        pcm_enabled_flag                            : 1;
+            uint32_t        scaling_list_enabled_flag                   : 1;
+            uint32_t        transform_skip_enabled_flag                 : 1;
+            uint32_t        amp_enabled_flag                            : 1;
+            uint32_t        strong_intra_smoothing_enabled_flag         : 1;
+            uint32_t        sign_data_hiding_enabled_flag               : 1;
+            uint32_t        constrained_intra_pred_flag                 : 1;
+            uint32_t        cu_qp_delta_enabled_flag                    : 1;
+            uint32_t        weighted_pred_flag                          : 1;
+            uint32_t        weighted_bipred_flag                        : 1;
+            uint32_t        transquant_bypass_enabled_flag              : 1;
+            uint32_t        tiles_enabled_flag                          : 1;
+            uint32_t        entropy_coding_sync_enabled_flag            : 1;
+            uint32_t        pps_loop_filter_across_slices_enabled_flag  : 1;
+            uint32_t        loop_filter_across_tiles_enabled_flag       : 1;
+            uint32_t        pcm_loop_filter_disabled_flag               : 1;
+            /** set based on sps_max_num_reorder_pics of current temporal layer. */
+            uint32_t        NoPicReorderingFlag                         : 1;
+            /** picture has no B slices */
+            uint32_t        NoBiPredFlag                                : 1;
+
+            uint32_t        ReservedBits                                : 11;
+        } bits;
+        uint32_t            value;
+    } pic_fields;
+
+    /** following parameters have same syntax with those in HEVC spec */
+    /** \brief DPB size for current temporal layer */
+    uint8_t                 sps_max_dec_pic_buffering_minus1;
+    uint8_t                 bit_depth_luma_minus8;
+    uint8_t                 bit_depth_chroma_minus8;
+    uint8_t                 pcm_sample_bit_depth_luma_minus1;
+    uint8_t                 pcm_sample_bit_depth_chroma_minus1;
+    uint8_t                 log2_min_luma_coding_block_size_minus3;
+    uint8_t                 log2_diff_max_min_luma_coding_block_size;
+    uint8_t                 log2_min_transform_block_size_minus2;
+    uint8_t                 log2_diff_max_min_transform_block_size;
+    uint8_t                 log2_min_pcm_luma_coding_block_size_minus3;
+    uint8_t                 log2_diff_max_min_pcm_luma_coding_block_size;
+    uint8_t                 max_transform_hierarchy_depth_intra;
+    uint8_t                 max_transform_hierarchy_depth_inter;
+    int8_t                  init_qp_minus26;
+    uint8_t                 diff_cu_qp_delta_depth;
+    int8_t                  pps_cb_qp_offset;
+    int8_t                  pps_cr_qp_offset;
+    uint8_t                 log2_parallel_merge_level_minus2;
+    uint8_t                 num_tile_columns_minus1;
+    uint8_t                 num_tile_rows_minus1;
+    /**
+     * when uniform_spacing_flag equals 1, application should populate
+     * column_width_minus[], and row_height_minus1[] with approperiate values.
+     */
+    uint16_t                column_width_minus1[19];
+    uint16_t                row_height_minus1[21];
+
+    /**
+     *  The Following Parameters are needed for Short Slice Format Only.
+     *  Only format decoding can ignore them.
+     */
+
+    /**
+     * \brief Parameters needed for parsing slice segment headers
+     */
+    union
+    {
+        struct
+        {
+            /** following parameters have same syntax with those in HEVC spec */
+            uint32_t        lists_modification_present_flag             : 1;
+            uint32_t        long_term_ref_pics_present_flag             : 1;
+            uint32_t        sps_temporal_mvp_enabled_flag               : 1;
+            uint32_t        cabac_init_present_flag                     : 1;
+            uint32_t        output_flag_present_flag                    : 1;
+            uint32_t        dependent_slice_segments_enabled_flag       : 1;
+            uint32_t        pps_slice_chroma_qp_offsets_present_flag    : 1;
+            uint32_t        sample_adaptive_offset_enabled_flag         : 1;
+            uint32_t        deblocking_filter_override_enabled_flag     : 1;
+            uint32_t        pps_disable_deblocking_filter_flag          : 1;
+            uint32_t        slice_segment_header_extension_present_flag : 1;
+
+            /** current picture with NUT between 16 and 21 inclusive */
+            uint32_t        RapPicFlag                                  : 1;
+            /** current picture with NUT between 19 and 20 inclusive */
+            uint32_t        IdrPicFlag                                  : 1;
+            /** current picture has only intra slices */
+            uint32_t        IntraPicFlag                                : 1;
+
+            uint32_t        ReservedBits                                : 18;
+        } bits;
+        uint32_t            value;
+    } slice_parsing_fields;
+
+    /** following parameters have same syntax with those in HEVC spec */
+    uint8_t                 log2_max_pic_order_cnt_lsb_minus4;
+    uint8_t                 num_short_term_ref_pic_sets;
+    uint8_t                 num_long_term_ref_pic_sps;
+    uint8_t                 num_ref_idx_l0_default_active_minus1;
+    uint8_t                 num_ref_idx_l1_default_active_minus1;
+    int8_t                  pps_beta_offset_div2;
+    int8_t                  pps_tc_offset_div2;
+    uint8_t                 num_extra_slice_header_bits;
+
+    /**
+     * \brief number of bits that structure
+     * short_term_ref_pic_set( num_short_term_ref_pic_sets ) takes in slice
+     * segment header when short_term_ref_pic_set_sps_flag equals 0.
+     * if short_term_ref_pic_set_sps_flag equals 1, the value should be 0.
+     * the bit count is calculated after emulation prevention bytes are removed
+     * from bit streams.
+     * This variable is used for accelorater to skip parsing the
+     * short_term_ref_pic_set( num_short_term_ref_pic_sets ) structure.
+     */
+    uint32_t                st_rps_bits;
+
+} VAPictureParameterBufferHEVC;
+
+
+
+/**
+ * \brief HEVC Slice Parameter Buffer Structure For Short Format
+ *
+ * VASliceParameterBufferBaseHEVC structure should be accompanied by a
+ * slice data buffer, which holds the whole raw slice NAL unit bit streams
+ * including start code prefix and emulation prevention bytes not removed.
+ *
+ * This structure conveys parameters related to slice segment header and should
+ * be sent once per slice.
+ *
+ * For long format, this data structure is not sent by application.
+ *
+ */
+typedef struct  _VASliceParameterBufferBaseHEVC
+{
+    /** @name Codec-independent Slice Parameter Buffer base. */
+
+    /**@{*/
+
+    /** \brief Number of bytes in the slice data buffer for this slice
+     *  counting from and including NAL unit header.
+     */
+    uint32_t                slice_data_size;
+    /** \brief The offset to the NAL unit header for this slice */
+    uint32_t                slice_data_offset;
+    /** \brief Slice data buffer flags. See \c VA_SLICE_DATA_FLAG_XXX. */
+    uint16_t                slice_data_flag;
+    /**@}*/
+
+} VASliceParameterBufferBaseHEVC;
+
+
+
+
+/**
+ * \brief HEVC Slice Parameter Buffer Structure For Long Format
+ *
+ * VASliceParameterBufferHEVC structure should be accompanied by a
+ * slice data buffer, which holds the whole raw slice NAL unit bit streams
+ * including start code prefix and emulation prevention bytes not removed.
+ *
+ * This structure conveys parameters related to slice segment header and should
+ * be sent once per slice.
+ *
+ * For short format, this data structure is not sent by application.
+ *
+ */
+typedef struct  _VASliceParameterBufferHEVC
+{
+    /** @name Codec-independent Slice Parameter Buffer base. */
+
+    /**@{*/
+
+    /** \brief Number of bytes in the slice data buffer for this slice
+     * counting from and including NAL unit header.
+     */
+    uint32_t                slice_data_size;
+    /** \brief The offset to the NAL unit header for this slice */
+    uint32_t                slice_data_offset;
+    /** \brief Slice data buffer flags. See \c VA_SLICE_DATA_FLAG_XXX. */
+    uint16_t                slice_data_flag;
+    /**
+     * \brief Byte offset from NAL unit header to the begining of slice_data().
+     *
+     * This byte offset is relative to and includes the NAL unit header
+     * and represents the number of bytes parsed in the slice_header()
+     * after the removal of any emulation prevention bytes in
+     * there. However, the slice data buffer passed to the hardware is
+     * the original bitstream, thus including any emulation prevention
+     * bytes.
+     */
+    uint32_t                slice_data_byte_offset;
+    /** HEVC syntax element. */
+    uint32_t                slice_segment_address;
+    /** \brief index into ReferenceFrames[]
+     * RefPicList[0][] corresponds to RefPicList0[] of HEVC variable.
+     * RefPicList[1][] corresponds to RefPicList1[] of HEVC variable.
+     * value range [0..14, 0xFF], where 0xFF indicates invalid entry.
+     */
+    uint8_t                 RefPicList[2][15];
+    union
+    {
+        uint32_t            value;
+        struct
+        {
+            /** current slice is last slice of picture. */
+            uint32_t        LastSliceOfPic                              : 1;
+    /** HEVC syntax element. */
+            uint32_t        dependent_slice_segment_flag                : 1;
+    /** HEVC syntax element. */
+            uint32_t        slice_type                                  : 2;
+    /** HEVC syntax element. */
+            uint32_t        color_plane_id                              : 2;
+    /** HEVC syntax element. */
+            uint32_t        slice_sao_luma_flag                         : 1;
+    /** HEVC syntax element. */
+            uint32_t        slice_sao_chroma_flag                       : 1;
+    /** HEVC syntax element. */
+            uint32_t        mvd_l1_zero_flag                            : 1;
+    /** HEVC syntax element. */
+            uint32_t        cabac_init_flag                             : 1;
+    /** HEVC syntax element. */
+            uint32_t        slice_temporal_mvp_enabled_flag             : 1;
+    /** HEVC syntax element. */
+            uint32_t        slice_deblocking_filter_disabled_flag       : 1;
+    /** HEVC syntax element. */
+            uint32_t        collocated_from_l0_flag                     : 1;
+    /** HEVC syntax element. */
+            uint32_t        slice_loop_filter_across_slices_enabled_flag : 1;
+            uint32_t        reserved                                    : 18;
+        } fields;
+    } LongSliceFlags;
+
+    /** HEVC syntax element. Collocated Reference Picture Index.
+     * index to RefPicList[0][] or RefPicList[1][].
+     * when slice_temporal_mvp_enabled_flag equals 0, it should take value 0xFF.
+     * value range [0..14, 0xFF].
+     */
+    uint8_t                 collocated_ref_idx;
+    /** HEVC syntax element.
+     * if num_ref_idx_active_override_flag equals 0, host decoder should
+     * set its value to num_ref_idx_l0_default_minus1.
+     */
+    uint8_t                 num_ref_idx_l0_active_minus1;
+    /** HEVC syntax element.
+     * if num_ref_idx_active_override_flag equals 0, host decoder should
+     * set its value to num_ref_idx_l1_default_minus1.
+     */
+    uint8_t                 num_ref_idx_l1_active_minus1;
+    /** HEVC syntax element. */
+    int8_t                  slice_qp_delta;
+    /** HEVC syntax element. */
+    int8_t                  slice_cb_qp_offset;
+    /** HEVC syntax element. */
+    int8_t                  slice_cr_qp_offset;
+    /** HEVC syntax element. */
+    int8_t                  slice_beta_offset_div2;
+    /** HEVC syntax element. */
+    int8_t                  slice_tc_offset_div2;
+    /** HEVC syntax element. */
+    uint8_t                 luma_log2_weight_denom;
+    /** HEVC syntax element. */
+    int8_t                  delta_chroma_log2_weight_denom;
+    /** HEVC syntax element. */
+    int8_t                  delta_luma_weight_l0[15];
+    /** HEVC syntax element. */
+    int8_t                  luma_offset_l0[15];
+    /** HEVC syntax element. */
+    int8_t                  delta_chroma_weight_l0[15][2];
+    /** corresponds to HEVC spec variable of the same name. */
+    int8_t                  ChromaOffsetL0[15][2];
+    /** HEVC syntax element. */
+    int8_t                  delta_luma_weight_l1[15];
+    /** HEVC syntax element. */
+    int8_t                  luma_offset_l1[15];
+    /** HEVC syntax element. */
+    int8_t                  delta_chroma_weight_l1[15][2];
+    /** corresponds to HEVC spec variable of the same name. */
+    int8_t                  ChromaOffsetL1[15][2];
+    /** HEVC syntax element. */
+    uint8_t                 five_minus_max_num_merge_cand;
+    /**@}*/
+
+} VASliceParameterBufferHEVC;
+
+
+
+/**
+ * \brief HEVC Inverse Quantization Matrix Buffer Structure
+ *
+ * This structure is sent once per frame,
+ * and only when scaling_list_enabled_flag = 1.
+ * When sps_scaling_list_data_present_flag = 0, app still
+ * needs to send in this structure with default matrix values.
+ *
+ * Matrix entries are in raster scan order which follows HEVC spec.
+ */
+typedef struct _VAIQMatrixBufferHEVC
+{
+    /**
+     * \brief scaling lists,
+     * corresponds to same HEVC spec syntax element
+     * ScalingList[ i ][ MatrixID ][ j ].
+     *
+     * \brief 4x4 scaling,
+     * correspongs i = 0, MatrixID is in the range of 0 to 5,
+     * inclusive. And j is in the range of 0 to 15, inclusive.
+     */
+    uint8_t                 ScalingList4x4[6][16];
+    /**
+     * \brief 8x8 scaling,
+     * correspongs i = 1, MatrixID is in the range of 0 to 5,
+     * inclusive. And j is in the range of 0 to 63, inclusive.
+     */
+    uint8_t                 ScalingList8x8[6][64];
+    /**
+     * \brief 16x16 scaling,
+     * correspongs i = 2, MatrixID is in the range of 0 to 5,
+     * inclusive. And j is in the range of 0 to 63, inclusive.
+     */
+    uint8_t                 ScalingList16x16[6][64];
+    /**
+     * \brief 32x32 scaling,
+     * correspongs i = 3, MatrixID is in the range of 0 to 1,
+     * inclusive. And j is in the range of 0 to 63, inclusive.
+     */
+    uint8_t                 ScalingList32x32[2][64];
+    /**
+     * \brief DC values of the 16x16 scaling lists,
+     * corresponds to HEVC spec syntax
+     * scaling_list_dc_coef_minus8[ sizeID - 2 ][ matrixID ] + 8
+     * with sizeID = 2 and matrixID in the range of 0 to 5, inclusive.
+     */
+    uint8_t                 ScalingListDC16x16[6];
+    /**
+     * \brief DC values of the 32x32 scaling lists,
+     * corresponds to HEVC spec syntax
+     * scaling_list_dc_coef_minus8[ sizeID - 2 ][ matrixID ] + 8
+     * with sizeID = 3 and matrixID in the range of 0 to 1, inclusive.
+     */
+    uint8_t                 ScalingListDC32x32[2];
+} VAIQMatrixBufferHEVC;
+
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* VA_DEC_HEVC_H */
--- /dev/null
+++ src/gallium/state_trackers/va/va/va_dec_jpeg.h
@@ -0,0 +1,142 @@
+/*
+ * Copyright (c) 2007-2012 Intel Corporation. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/**
+ * \file va_dec_jpeg.h
+ * \brief The JPEG decoding API
+ *
+ * This file contains the \ref api_dec_jpeg "JPEG decoding API".
+ */
+
+#ifndef VA_DEC_JPEG_H
+#define VA_DEC_JPEG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <va/va.h>
+
+/**
+ * \defgroup api_dec_jpeg JPEG decoding API
+ *
+ * This JPEG decoding API supports Baseline profile only.
+ *
+ * @{
+ */
+
+/**
+ * \brief Picture parameter for JPEG decoding.
+ *
+ * This structure holds information from the frame header, along with
+ * definitions from additional segments.
+ */
+typedef struct _VAPictureParameterBufferJPEGBaseline {
+    /** \brief Picture width in pixels. */
+    unsigned short      picture_width;
+    /** \brief Picture height in pixels. */
+    unsigned short      picture_height;
+
+    struct {
+        /** \brief Component identifier (Ci). */
+        unsigned char   component_id;
+        /** \brief Horizontal sampling factor (Hi). */
+        unsigned char   h_sampling_factor;
+        /** \brief Vertical sampling factor (Vi). */
+        unsigned char   v_sampling_factor;
+        /* \brief Quantization table selector (Tqi). */
+        unsigned char   quantiser_table_selector;
+    }                   components[255];
+    /** \brief Number of components in frame (Nf). */
+    unsigned char       num_components;
+} VAPictureParameterBufferJPEGBaseline;
+
+/**
+ * \brief Quantization table for JPEG decoding.
+ *
+ * This structure holds the complete quantization tables. This is an
+ * aggregation of all quantization table (DQT) segments maintained by
+ * the application. i.e. up to 4 quantization tables are stored in
+ * there for baseline profile.
+ *
+ * The #load_quantization_table array can be used as a hint to notify
+ * the VA driver implementation about which table(s) actually changed
+ * since the last submission of this buffer.
+ *
+ * The #quantiser_table values are specified in zig-zag scan order.
+ */
+typedef struct _VAIQMatrixBufferJPEGBaseline {
+    /** \brief Specifies which #quantiser_table is valid. */
+    unsigned char       load_quantiser_table[4];
+    /** \brief Quanziation tables indexed by table identifier (Tqi). */
+    unsigned char       quantiser_table[4][64];
+} VAIQMatrixBufferJPEGBaseline;
+
+/**
+ * \brief Slice parameter for JPEG decoding.
+ *
+ * This structure holds information from the scan header, along with
+ * definitions from additional segments. The associated slice data
+ * buffer holds all entropy coded segments (ECS) in the scan.
+ */
+typedef struct _VASliceParameterBufferJPEGBaseline {
+    /** @name Codec-independent Slice Parameter Buffer base. */
+    /**@{*/
+    /** \brief Number of bytes in the slice data buffer for this slice. */
+    unsigned int        slice_data_size;
+    /** \brief The offset to the first byte of the first MCU. */
+    unsigned int        slice_data_offset;
+    /** \brief Slice data buffer flags. See \c VA_SLICE_DATA_FLAG_xxx. */
+    unsigned int        slice_data_flag;
+    /**@}*/
+
+    /** \brief Scan horizontal position. */
+    unsigned int        slice_horizontal_position;
+    /** \brief Scan vertical position. */
+    unsigned int        slice_vertical_position;
+
+    struct {
+        /** \brief Scan component selector (Csj). */
+        unsigned char   component_selector;
+        /** \brief DC entropy coding table selector (Tdj). */
+        unsigned char   dc_table_selector;
+        /** \brief AC entropy coding table selector (Taj). */
+        unsigned char   ac_table_selector;
+    }                   components[4];
+    /** \brief Number of components in scan (Ns). */
+    unsigned char       num_components;
+
+    /** \brief Restart interval definition (Ri). */
+    unsigned short      restart_interval;
+    /** \brief Number of MCUs in a scan. */
+    unsigned int        num_mcus;
+} VASliceParameterBufferJPEGBaseline;
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* VA_DEC_JPEG_H */
--- /dev/null
+++ src/gallium/state_trackers/va/va/va_dec_vp8.h
@@ -0,0 +1,243 @@
+/*
+ * Copyright (c) 2007-2012 Intel Corporation. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/**
+ * \file va_dec_vp.h
+ * \brief VP8 decoding API
+ *
+ * This file contains the \ref api_dec_vp8 "VP8 decoding API".
+ */
+
+#ifndef VA_DEC_VP8_H
+#define VA_DEC_VP8_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \defgroup api_dec_vp8 VP8 decoding API
+ *
+ * @{
+ */
+
+/**
+ * \brief VPX Bool Coder Context structure 
+ *
+ * This common structure is defined for potential sharing by other VP formats
+ *
+ */
+typedef struct _VABoolCoderContextVPX
+{
+    /* partition 0 "range" */
+    unsigned char range;
+    /* partition 0 "value" */
+    unsigned char value;
+    /*
+     * 'partition 0 number of shifts before an output byte is available'
+     * it is the number of remaining bits in 'value' for decoding, range [0, 7].
+     */
+
+    unsigned char count;
+} VABoolCoderContextVPX;
+
+/**
+ * \brief VP8 Decoding Picture Parameter Buffer Structure
+ *
+ * This structure conveys frame level parameters and should be sent once
+ * per frame.
+ *
+ */
+typedef struct  _VAPictureParameterBufferVP8
+{
+    /* frame width in pixels */
+    unsigned int frame_width;
+    /* frame height in pixels */
+    unsigned int frame_height;
+
+    /* specifies the "last" reference frame */
+    VASurfaceID last_ref_frame;
+    /* specifies the "golden" reference frame */
+    VASurfaceID golden_ref_frame;
+    /* specifies the "alternate" referrence frame */
+    VASurfaceID alt_ref_frame;
+    /* specifies the out-of-loop deblocked frame, not used currently */
+    VASurfaceID out_of_loop_frame;
+
+    union {
+        struct {
+	    /* same as key_frame in bitstream syntax, 0 means a key frame */
+            unsigned int key_frame			: 1; 
+	    /* same as version in bitstream syntax */
+            unsigned int version			: 3;
+	    /* same as segmentation_enabled in bitstream syntax */
+            unsigned int segmentation_enabled		: 1;
+	    /* same as update_mb_segmentation_map in bitstream syntax */
+            unsigned int update_mb_segmentation_map	: 1;
+	    /* same as update_segment_feature_data in bitstream syntax */
+            unsigned int update_segment_feature_data	: 1;
+	    /* same as filter_type in bitstream syntax */
+            unsigned int filter_type			: 1; 
+	    /* same as sharpness_level in bitstream syntax */
+            unsigned int sharpness_level		: 3; 
+	    /* same as loop_filter_adj_enable in bitstream syntax */
+            unsigned int loop_filter_adj_enable		: 1; 
+	    /* same as mode_ref_lf_delta_update in bitstream syntax */
+            unsigned int mode_ref_lf_delta_update	: 1; 
+	    /* same as sign_bias_golden in bitstream syntax */
+            unsigned int sign_bias_golden		: 1; 
+	    /* same as sign_bias_alternate in bitstream syntax */
+            unsigned int sign_bias_alternate		: 1; 
+	    /* same as mb_no_coeff_skip in bitstream syntax */
+            unsigned int mb_no_coeff_skip		: 1; 
+	    /* flag to indicate that loop filter should be disabled */
+            unsigned int loop_filter_disable		: 1; 
+        } bits;
+        unsigned int value;
+    } pic_fields;
+
+    /*
+     * probabilities of the segment_id decoding tree and same as 
+     * mb_segment_tree_probs in the spec.
+     */
+    unsigned char mb_segment_tree_probs[3];
+
+    /* Post-adjustment loop filter levels for the 4 segments */
+    unsigned char loop_filter_level[4];
+    /* loop filter deltas for reference frame based MB level adjustment */
+    char loop_filter_deltas_ref_frame[4];
+    /* loop filter deltas for coding mode based MB level adjustment */
+    char loop_filter_deltas_mode[4];
+
+    /* same as prob_skip_false in bitstream syntax */
+    unsigned char prob_skip_false;
+    /* same as prob_intra in bitstream syntax */
+    unsigned char prob_intra;
+    /* same as prob_last in bitstream syntax */
+    unsigned char prob_last;
+    /* same as prob_gf in bitstream syntax */
+    unsigned char prob_gf;
+
+    /* 
+     * list of 4 probabilities of the luma intra prediction mode decoding
+     * tree and same as y_mode_probs in frame header
+     */
+    unsigned char y_mode_probs[4]; 
+    /*
+     * list of 3 probabilities of the chroma intra prediction mode decoding
+     * tree and same as uv_mode_probs in frame header
+     */
+    unsigned char uv_mode_probs[3];
+    /* 
+     * updated mv decoding probabilities and same as mv_probs in 
+     * frame header
+     */
+    unsigned char mv_probs[2][19];
+
+    VABoolCoderContextVPX bool_coder_ctx;
+
+} VAPictureParameterBufferVP8;
+
+/**
+ * \brief VP8 Slice Parameter Buffer Structure
+ *
+ * This structure conveys parameters related to data partitions and should be 
+ * sent once per frame. Slice data buffer of VASliceDataBufferType is used
+ * to send the partition data.
+ *
+ */
+typedef struct  _VASliceParameterBufferVP8
+{
+    /*
+     * number of bytes in the slice data buffer for the partitions 
+     */
+    unsigned int slice_data_size;
+    /*
+     * offset to the first byte of partition data (control partition)
+     */
+    unsigned int slice_data_offset;
+    /*
+     * see VA_SLICE_DATA_FLAG_XXX definitions
+     */
+    unsigned int slice_data_flag; 
+    /*
+     * offset to the first bit of MB from the first byte of partition data(slice_data_offset)
+     */
+    unsigned int macroblock_offset;
+
+    /*
+     * Partitions
+     * (1<<log2_nbr_of_dct_partitions)+1, count both control partition (frame header) and toke partition
+     */
+    unsigned char num_of_partitions;
+    /*
+     * partition_size[0] is remaining bytes of control partition after parsed by application.
+     * exclude current byte for the remaining bits in bool_coder_ctx.
+     * exclude the uncompress data chunk since first_part_size 'excluding the uncompressed data chunk'
+     */
+    unsigned int partition_size[9];
+} VASliceParameterBufferVP8;
+
+/**
+ * \brief VP8 Coefficient Probability Data Buffer Structure
+ *
+ * Contains the contents of the token probability table, which may be 
+ * incrementally modified in the frame header. There are four dimensions to 
+ * the token probability array. The outermost dimension is indexed by the 
+ * type of plane being decoded; the next dimension is selected by the 
+ * position of the coefficient being decoded; the third dimension, * roughly 
+ * speaking, measures the "local complexity" or extent to which nearby 
+ * coefficients are non-zero; the fourth, and final, dimension of the token 
+ * probability array is indexed by the position in the token tree structure, 
+ * as are all tree probability arrays. This structure is sent once per frame.
+ *
+ */
+typedef struct _VAProbabilityDataBufferVP8
+{
+    unsigned char dct_coeff_probs[4][8][3][11];
+} VAProbabilityDataBufferVP8;
+
+/**
+ * \brief VP8 Inverse Quantization Matrix Buffer Structure
+ *
+ * Contains quantization indices for yac(0),ydc(1),y2dc(2),y2ac(3),uvdc(4),
+ * uvac(5) for each segment (0-3). When segmentation is disabled, only  
+ * quantization_index[0][] will be used. This structure is sent once per frame.
+ */
+typedef struct _VAIQMatrixBufferVP8
+{
+    /* 
+     * array first dimensional is segment and 2nd dimensional is Q index
+     * all Q indexs should be clipped to be range [0, 127]
+     */
+    unsigned short quantization_index[4][6];
+} VAIQMatrixBufferVP8;
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* VA_DEC_VP8_H */
--- /dev/null
+++ src/gallium/state_trackers/va/va/va_dec_vp9.h
@@ -0,0 +1,316 @@
+/*
+ * Copyright (c) 2014 Intel Corporation. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/**
+ * \file va_dec_vp9.h
+ * \brief The VP9 decoding API
+ *
+ * This file contains the \ref api_dec_vp9 "VP9 decoding API".
+ */
+
+#ifndef VA_DEC_VP9_H
+#define VA_DEC_VP9_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \defgroup api_dec_vp9 VP9 decoding API
+ *
+ * This VP9 decoding API supports 8-bit 420 format only.
+ *
+ * @{
+ */
+
+
+
+
+/**
+ * \brief VP9 Decoding Picture Parameter Buffer Structure
+ *
+ * This structure conveys picture level parameters.
+ * App should send a surface with this data structure down to VAAPI once
+ * per frame.
+ *
+ */
+typedef struct  _VADecPictureParameterBufferVP9
+{
+    /**@{*/
+
+    /** \brief picture width
+     *  Picture original resolution. The value may not be multiple of 8.
+     */
+    uint16_t                frame_width;
+    /** \brief picture height
+     *  Picture original resolution. The value may not be multiple of 8.
+     */
+    uint16_t                frame_height;
+
+    /** \brief Surface indices of reference frames in DPB.
+     *
+     *  Each entry of the list specifies the surface index of the picture
+     *  that is referred by current picture or will be referred by any future
+     *  picture.
+     *  Application who calls this API should update this list based on the
+     *  refreshing information from VP9 bitstream.
+     */
+    VASurfaceID             reference_frames[8];
+
+    union
+    {
+        struct
+        {
+            /** \brief flags for current picture
+             *  same syntax and semantic as those in VP9 code
+             */
+            uint32_t        subsampling_x                               : 1;
+            uint32_t        subsampling_y                               : 1;
+            uint32_t        frame_type                                  : 1;
+            uint32_t        show_frame                                  : 1;
+            uint32_t        error_resilient_mode                        : 1;
+            uint32_t        intra_only                                  : 1;
+            uint32_t        allow_high_precision_mv                     : 1;
+            uint32_t        mcomp_filter_type                           : 3;
+            uint32_t        frame_parallel_decoding_mode                : 1;
+            uint32_t        reset_frame_context                         : 2;
+            uint32_t        refresh_frame_context                       : 1;
+            uint32_t        frame_context_idx                           : 2;
+            uint32_t        segmentation_enabled                        : 1;
+
+            /** \brief corresponds to variable temporal_update in VP9 code.
+             */
+            uint32_t        segmentation_temporal_update                : 1;
+            /** \brief corresponds to variable update_mb_segmentation_map
+             *  in VP9 code.
+             */
+            uint32_t        segmentation_update_map                     : 1;
+
+            /** \brief Index of reference_frames[] and points to the
+             *  LAST reference frame.
+             *  It corresponds to active_ref_idx[0] in VP9 code.
+             */
+            uint32_t        last_ref_frame                              : 3;
+            /** \brief Sign Bias of the LAST reference frame.
+             *  It corresponds to ref_frame_sign_bias[LAST_FRAME] in VP9 code.
+             */
+            uint32_t        last_ref_frame_sign_bias                    : 1;
+            /** \brief Index of reference_frames[] and points to the
+             *  GOLDERN reference frame.
+             *  It corresponds to active_ref_idx[1] in VP9 code.
+             */
+            uint32_t        golden_ref_frame                            : 3;
+            /** \brief Sign Bias of the GOLDERN reference frame.
+             *  Corresponds to ref_frame_sign_bias[GOLDERN_FRAME] in VP9 code.
+             */
+            uint32_t        golden_ref_frame_sign_bias                  : 1;
+            /** \brief Index of reference_frames[] and points to the
+             *  ALTERNATE reference frame.
+             *  Corresponds to active_ref_idx[2] in VP9 code.
+             */
+            uint32_t        alt_ref_frame                               : 3;
+            /** \brief Sign Bias of the ALTERNATE reference frame.
+             *  Corresponds to ref_frame_sign_bias[ALTREF_FRAME] in VP9 code.
+             */
+            uint32_t        alt_ref_frame_sign_bias                     : 1;
+            /** \brief Lossless Mode
+             *  LosslessFlag = base_qindex == 0 &&
+             *                 y_dc_delta_q == 0 &&
+             *                 uv_dc_delta_q == 0 &&
+             *                 uv_ac_delta_q == 0;
+             *  Where base_qindex, y_dc_delta_q, uv_dc_delta_q and uv_ac_delta_q
+             *  are all variables in VP9 code.
+             */
+            uint32_t        lossless_flag                               : 1;
+        } bits;
+        uint32_t            value;
+    } pic_fields;
+
+    /* following parameters have same syntax with those in VP9 code */
+    uint8_t                 filter_level;
+    uint8_t                 sharpness_level;
+
+    /** \brief number of tile rows specified by (1 << log2_tile_rows).
+     *  It corresponds the variable with same name in VP9 code.
+     */
+    uint8_t                 log2_tile_rows;
+    /** \brief number of tile columns specified by (1 << log2_tile_columns).
+     *  It corresponds the variable with same name in VP9 code.
+     */
+    uint8_t                 log2_tile_columns;
+    /** \brief Number of bytes taken up by the uncompressed frame header,
+     *  which corresponds to byte length of function
+     *  read_uncompressed_header() in VP9 code.
+     *  Specifically, it is the byte count from bit stream buffer start to
+     *  the last byte of uncompressed frame header.
+     *  If there are other meta data in the buffer before uncompressed header,
+     *  its size should be also included here.
+     */
+    uint8_t                 frame_header_length_in_bytes;
+
+    /** \brief The byte count of compressed header the bitstream buffer,
+     *  which corresponds to syntax first_partition_size in code.
+     */
+    uint16_t                first_partition_size;
+
+    /** These values are segment probabilities with same names in VP9
+     *  function setup_segmentation(). They should be parsed directly from
+     *  bitstream by application.
+     */
+    uint8_t                 mb_segment_tree_probs[7];
+    uint8_t                 segment_pred_probs[3];
+
+    /** \brief VP9 Profile definition
+     *  value can be 0 or 1.
+     */
+    uint8_t                 profile;
+
+    /**@}*/
+
+} VADecPictureParameterBufferVP9;
+
+
+
+/**
+ * \brief VP9 Segmentation Parameter Data Structure
+ *
+ * This structure conveys per segment parameters.
+ * 8 of this data structure will be included in VASegmentationParameterBufferVP9
+ * and sent to API in a single buffer.
+ *
+ */
+typedef struct  _VASegmentParameterVP9
+{
+    /**@{*/
+
+    union
+    {
+        struct
+        {
+            /** \brief Indicates if per segment reference frame indicator
+             *  is enabled.
+             *  Corresponding to variable feature_enabled when
+             *  j == SEG_LVL_REF_FRAME in function setup_segmentation() VP9 code.
+             */
+            uint16_t        segment_reference_enabled                   : 1;
+            /** \brief Specifies per segment reference indication.
+             *  0: reserved
+             *  1: Last ref
+             *  2: golden
+             *  3: altref
+             *  Value can be derived from variable data when
+             *  j == SEG_LVL_REF_FRAME in function setup_segmentation() VP9 code.
+             */
+            uint16_t        segment_reference                           : 2;
+            /** \brief Indicates if per segment skip feature is enabled.
+             *  Corresponding to variable feature_enabled when
+             *  j == SEG_LVL_SKIP in function setup_segmentation() VP9 code.
+             */
+            uint16_t        segment_reference_skipped                   : 1;
+        } fields;
+        uint16_t            value;
+    } segment_flags;
+
+    /** \brief Specifies the filter level information per segment.
+     *  The value corresponds to variable lfi->lvl[seg][ref][mode] in VP9 code,
+     *  where m is [ref], and n is [mode] in FilterLevel[m][n].
+     */
+    uint8_t                 filter_level[4][2];
+    /** \brief Specifies per segment Luma AC quantization scale.
+     *  Corresponding to y_dequant[qindex][1] in vp9_mb_init_quantizer()
+     *  function of VP9 code.
+     */
+    int16_t                 luma_ac_quant_scale;
+    /** \brief Specifies per segment Luma DC quantization scale.
+     *  Corresponding to y_dequant[qindex][0] in vp9_mb_init_quantizer()
+     *  function of VP9 code.
+     */
+    int16_t                 luma_dc_quant_scale;
+    /** \brief Specifies per segment Chroma AC quantization scale.
+     *  Corresponding to uv_dequant[qindex][1] in vp9_mb_init_quantizer()
+     *  function of VP9 code.
+     */
+    int16_t                 chroma_ac_quant_scale;
+    /** \brief Specifies per segment Chroma DC quantization scale.
+     *  Corresponding to uv_dequant[qindex][0] in vp9_mb_init_quantizer()
+     *  function of VP9 code.
+     */
+    int16_t                 chroma_dc_quant_scale;
+
+    /**@}*/
+
+} VASegmentParameterVP9;
+
+
+
+/**
+ * \brief VP9 Slice Parameter Buffer Structure
+ *
+ * This structure conveys parameters related to segmentation data and should be
+ * sent once per frame.
+ *
+ * When segmentation is disabled, only SegParam[0] has valid values,
+ * all other entries should be populated with 0.
+ * Otherwise, all eight entries should be valid.
+ *
+ * Slice data buffer of VASliceDataBufferType is used
+ * to send the bitstream which should include whole or part of partition 0
+ * (at least compressed header) to the end of frame.
+ *
+ */
+typedef struct _VASliceParameterBufferVP9
+{
+    /**@{*/
+    /** \brief The byte count of current frame in the bitstream buffer,
+     *  starting from first byte of the buffer.
+     *  It uses the name slice_data_size to be consitent with other codec,
+     *  but actually means frame_data_size.
+     */
+    uint32_t slice_data_size;
+    /**
+     * offset to the first byte of partition data (control partition)
+     */
+    uint32_t slice_data_offset;
+    /**
+     * see VA_SLICE_DATA_FLAG_XXX definitions
+     */
+    uint32_t slice_data_flag;
+
+    /**
+     * \brief per segment information
+     */
+    VASegmentParameterVP9   seg_param[8];
+
+    /**@}*/
+
+} VASliceParameterBufferVP9;
+
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* VA_DEC_VP9_H */
--- /dev/null
+++ src/gallium/state_trackers/va/va/va_enc_h264.h
@@ -0,0 +1,592 @@
+/*
+ * Copyright (c) 2007-2011 Intel Corporation. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/**
+ * \file va_enc_h264.h
+ * \brief The H.264 encoding API
+ *
+ * This file contains the \ref api_enc_h264 "H.264 encoding API".
+ */
+
+#ifndef VA_ENC_H264_H
+#define VA_ENC_H264_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \defgroup api_enc_h264 H.264 encoding API
+ *
+ * @{
+ */
+
+/**
+ * @name Picture flags
+ *
+ * Those flags flags are meant to signal when a picture marks the end
+ * of a sequence, a stream, or even both at once.
+ *
+ * @{
+ */
+/**
+ * \brief Marks the last picture in the sequence.
+ *
+ * i.e. the driver appends \c end_of_seq() NAL unit to the encoded frame.
+ */
+#define H264_LAST_PICTURE_EOSEQ     0x01
+/**
+ * \brief Marks the last picture in the stream.
+ *
+ * i.e. the driver appends \c end_of_stream() NAL unit to the encoded frame.
+ */
+#define H264_LAST_PICTURE_EOSTREAM  0x02
+/**@}*/
+
+/**
+ * \brief Packed header types specific to H.264 encoding.
+ *
+ * Types of packed headers generally used for H.264 encoding. Each
+ * associated packed header data buffer shall contain the start code
+ * prefix 0x000001 followed by the complete NAL unit, thus also
+ * including the \c nal_unit_type.
+ *
+ * Note: the start code prefix can contain an arbitrary number of leading
+ * zeros. The driver will skip them for emulation prevention bytes insertion,
+ * if necessary.
+ */
+typedef enum {
+    /**
+     * \brief Packed Sequence Parameter Set (SPS).
+     *
+     * The corresponding packed header data buffer shall contain the
+     * complete seq_parameter_set_rbsp() syntax element.
+     *
+     * Note: packed \c nal_unit_type shall be equal to 7.
+     */
+    VAEncPackedHeaderH264_SPS   = VAEncPackedHeaderSequence,
+    /**
+     * \brief Packed Picture Parameter Set (PPS).
+     *
+     * The corresponding packed header data buffer shall contain the
+     * complete pic_parameter_set_rbsp() syntax element.
+     *
+     * Note: packed \c nal_unit_type shall be equal to 8.
+     */
+    VAEncPackedHeaderH264_PPS   = VAEncPackedHeaderPicture,
+    /**
+     * \brief Packed slice header.
+     *
+     * The corresponding packed header data buffer shall contain the
+     * \c slice_header() syntax element only, along with any start
+     * code prefix and NAL unit type preceeding it. i.e. this means
+     * that the buffer does not contain any of the \c slice_data() or
+     * the \c rbsp_slice_trailing_bits().
+     *
+     * Note: packed \c nal_unit_type shall be equal to 1 (non-IDR
+     * picture), or 5 (IDR picture).
+     */
+    VAEncPackedHeaderH264_Slice = VAEncPackedHeaderSlice,
+    /**
+     * \brief Packed Supplemental Enhancement Information (SEI).
+     *
+     * The corresponding packed header data buffer shall contain the
+     * complete sei_rbsp() syntax element, thus including several
+     * sei_message() elements if necessary.
+     *
+     * Note: packed \c nal_unit_type shall be equal to 6.
+     */
+    VAEncPackedHeaderH264_SEI   = (VAEncPackedHeaderMiscMask | 1),
+} VAEncPackedHeaderTypeH264;
+
+/**
+ * \brief Sequence parameter for H.264 encoding in baseline, main & high 
+ * profiles.
+ *
+ * This structure holds information for \c seq_parameter_set_data() as
+ * defined by the H.264 specification.
+ *
+ * If packed sequence headers mode is used, i.e. if the encoding
+ * pipeline was configured with the #VA_ENC_PACKED_HEADER_SEQUENCE
+ * flag, then the driver expects two more buffers to be provided to
+ * the same \c vaRenderPicture() as this buffer:
+ * - a #VAEncPackedHeaderParameterBuffer with type set to
+ *   VAEncPackedHeaderType::VAEncPackedHeaderSequence ;
+ * - a #VAEncPackedHeaderDataBuffer which holds the actual packed
+ *   header data.
+ *
+ * If \c seq_scaling_matrix_present_flag is set to \c 1, then a
+ * #VAIQMatrixBufferH264 buffer shall also be provided within the same
+ * \c vaRenderPicture() call as this sequence parameter buffer.
+ */
+typedef struct _VAEncSequenceParameterBufferH264 {
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned char   seq_parameter_set_id;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned char   level_idc;
+    /** \brief Period between I frames. */
+    unsigned int    intra_period;
+    /** \brief Period between IDR frames. */
+    unsigned int    intra_idr_period;
+    /** \brief Period between I/P frames. */
+    unsigned int    ip_period;
+    /**
+     * \brief Initial bitrate set for this sequence in CBR or VBR modes.
+     *
+     * This field represents the initial bitrate value for this
+     * sequence if CBR or VBR mode is used, i.e. if the encoder
+     * pipeline was created with a #VAConfigAttribRateControl
+     * attribute set to either \ref VA_RC_CBR or \ref VA_RC_VBR.
+     *
+     * The bitrate can be modified later on through
+     * #VAEncMiscParameterRateControl buffers.
+     */
+    unsigned int    bits_per_second;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned int    max_num_ref_frames;
+    /** \brief Picture width in macroblocks. */
+    unsigned short  picture_width_in_mbs;
+    /** \brief Picture height in macroblocks. */
+    unsigned short  picture_height_in_mbs;
+
+    union {
+        struct {
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int chroma_format_idc                      : 2;
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int frame_mbs_only_flag                    : 1;
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int mb_adaptive_frame_field_flag           : 1;
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int seq_scaling_matrix_present_flag        : 1;
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int direct_8x8_inference_flag              : 1;
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int log2_max_frame_num_minus4              : 4;
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int pic_order_cnt_type                     : 2;
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int log2_max_pic_order_cnt_lsb_minus4      : 4;
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int delta_pic_order_always_zero_flag       : 1;
+        } bits;
+        unsigned int value;
+    } seq_fields;
+
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned char   bit_depth_luma_minus8;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned char   bit_depth_chroma_minus8;
+
+    /** if pic_order_cnt_type == 1 */
+    /**@{*/
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned char   num_ref_frames_in_pic_order_cnt_cycle;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    int             offset_for_non_ref_pic;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    int             offset_for_top_to_bottom_field;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    int             offset_for_ref_frame[256];
+    /**@}*/
+
+    /** @name Cropping (optional) */
+    /**@{*/
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned char   frame_cropping_flag;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned int    frame_crop_left_offset;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned int    frame_crop_right_offset;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned int    frame_crop_top_offset;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned int    frame_crop_bottom_offset;
+    /**@}*/
+
+    /** @name VUI parameters (optional) */
+    /**@{*/
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned char   vui_parameters_present_flag;
+    union {
+        struct {
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int aspect_ratio_info_present_flag         : 1;
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int timing_info_present_flag               : 1;
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int bitstream_restriction_flag             : 1;
+            /** \brief Range: 0 to 16, inclusive. */
+            unsigned int log2_max_mv_length_horizontal          : 5;
+            /** \brief Range: 0 to 16, inclusive. */
+            unsigned int log2_max_mv_length_vertical            : 5;
+        } bits;
+        unsigned int value;
+    } vui_fields;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned char   aspect_ratio_idc;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned int    sar_width;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned int    sar_height;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned int    num_units_in_tick;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned int    time_scale;
+    /**@}*/
+} VAEncSequenceParameterBufferH264;
+
+/**
+ * \brief Picture parameter for H.264 encoding in baseline, main & high 
+ * profiles.
+ *
+ * This structure holds information for \c pic_parameter_set_rbsp() as
+ * defined by the H.264 specification.
+ *
+ * If packed picture headers mode is used, i.e. if the encoding
+ * pipeline was configured with the #VA_ENC_PACKED_HEADER_PICTURE
+ * flag, then the driver expects two more buffers to be provided to
+ * the same \c vaRenderPicture() as this buffer:
+ * - a #VAEncPackedHeaderParameterBuffer with type set to
+ *   VAEncPackedHeaderType::VAEncPackedHeaderPicture ;
+ * - a #VAEncPackedHeaderDataBuffer which holds the actual packed
+ *   header data.
+ *
+ * If \c pic_scaling_matrix_present_flag is set to \c 1, then a
+ * #VAIQMatrixBufferH264 buffer shall also be provided within the same
+ * \c vaRenderPicture() call as this picture parameter buffer.
+ */
+typedef struct _VAEncPictureParameterBufferH264 {
+    /**
+     * \brief Information about the picture to be encoded.
+     *
+     * See #VAPictureH264 for further description of each field.
+     * Note that CurrPic.picture_id represents the reconstructed
+     * (decoded) picture. User provides a scratch VA surface ID here.
+     */
+    VAPictureH264   CurrPic;
+    /**
+     * \brief Decoded Picture Buffer (DPB).
+     *
+     * This array represents the list of reconstructed (decoded)
+     * frames used as reference. It is important to keep track of
+     * reconstructed frames so that they can be used later on as
+     * reference for P or B-frames encoding.
+     */
+    VAPictureH264   ReferenceFrames[16];
+    /**
+     * \brief Output encoded bitstream.
+     *
+     * \ref coded_buf has type #VAEncCodedBufferType. It should be
+     * large enough to hold the compressed NAL slice and possibly SPS
+     * and PPS NAL units.
+     */
+    VABufferID      coded_buf;
+
+    /** \brief The picture parameter set referred to in the slice header. */
+    unsigned char   pic_parameter_set_id;
+    /** \brief The active sequence parameter set. Range: 0 to 31, inclusive. */
+    unsigned char   seq_parameter_set_id;
+
+    /**
+     * \brief OR'd flags describing whether the picture is the last one or not.
+     *
+     * This fields holds 0 if the picture to be encoded is not the last
+     * one in the stream or sequence. Otherwise, it is a combination of
+     * \ref H264_LAST_PICTURE_EOSEQ or \ref H264_LAST_PICTURE_EOSTREAM.
+     */
+    unsigned char   last_picture;
+
+    /** \brief The picture identifier.
+     *   Range: 0 to \f$2^{log2\_max\_frame\_num\_minus4 + 4} - 1\f$, inclusive.
+     */
+    unsigned short  frame_num;
+
+    /** \brief \c pic_init_qp_minus26 + 26. */
+    unsigned char   pic_init_qp;
+    /** \brief Maximum reference index for reference picture list 0.
+     *   Range: 0 to 31, inclusive.
+     */
+    unsigned char   num_ref_idx_l0_active_minus1;
+    /** \brief Maximum reference index for reference picture list 1.
+     *  Range: 0 to 31, inclusive.
+     */
+    unsigned char   num_ref_idx_l1_active_minus1;
+
+    /** \brief Range: -12 to 12, inclusive. */
+    signed char     chroma_qp_index_offset;
+    /** \brief Range: -12 to 12, inclusive. */
+    signed char     second_chroma_qp_index_offset;
+
+    union {
+        struct {
+            /** \brief Is picture an IDR picture? */
+            unsigned int idr_pic_flag                           : 1;
+            /** \brief Is picture a reference picture? */
+            unsigned int reference_pic_flag                     : 2;
+            /** \brief Selects CAVLC (0) or CABAC (1) entropy coding mode. */
+            unsigned int entropy_coding_mode_flag               : 1;
+            /** \brief Is weighted prediction applied to P slices? */
+            unsigned int weighted_pred_flag                     : 1;
+            /** \brief Range: 0 to 2, inclusive. */
+            unsigned int weighted_bipred_idc                    : 2;
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int constrained_intra_pred_flag            : 1;
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int transform_8x8_mode_flag                : 1;
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int deblocking_filter_control_present_flag : 1;
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int redundant_pic_cnt_present_flag         : 1;
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int pic_order_present_flag                 : 1;
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int pic_scaling_matrix_present_flag        : 1;
+        } bits;
+        unsigned int value;
+    } pic_fields;
+} VAEncPictureParameterBufferH264;
+
+/**
+ * \brief Slice parameter for H.264 encoding in baseline, main & high profiles.
+ *
+ * This structure holds information for \c
+ * slice_layer_without_partitioning_rbsp() as defined by the H.264
+ * specification.
+ *
+ * If packed slice headers mode is used, i.e. if the encoding
+ * pipeline was configured with the #VA_ENC_PACKED_HEADER_SLICE
+ * flag, then the driver expects two more buffers to be provided to
+ * the same \c vaRenderPicture() as this buffer:
+ * - a #VAEncPackedHeaderParameterBuffer with type set to
+ *   VAEncPackedHeaderType::VAEncPackedHeaderSlice ;
+ * - a #VAEncPackedHeaderDataBuffer which holds the actual packed
+ *   header data.
+ *
+ * If per-macroblock encoder configuration is needed, \c macroblock_info
+ * references a buffer of type #VAEncMacroblockParameterBufferH264. This
+ * buffer is not passed to vaRenderPicture(). i.e. it is not destroyed
+ * by subsequent calls to vaRenderPicture() and then can be re-used
+ * without re-allocating the whole buffer.
+ */
+typedef struct _VAEncSliceParameterBufferH264 {
+    /** \brief Starting MB address for this slice. */
+    unsigned int    macroblock_address;
+    /** \brief Number of macroblocks in this slice. */
+    unsigned int    num_macroblocks;
+    /**
+     * \brief Per-MB encoder configuration buffer, or \c VA_INVALID_ID.
+     *
+     * If per-MB encoder configuration is needed, then \ref macroblock_info
+     * references a buffer of type #VAEncMacroblockParameterBufferH264
+     * (\c VAEncMacroblockParameterBufferType). Otherwise, buffer id
+     * is set to \c VA_INVALID_ID and per-MB configuration is derived
+     * from this slice parameter.
+     *
+     * The \c macroblock_info buffer must hold \ref num_macroblocks
+     * elements.
+     */
+    VABufferID      macroblock_info;
+    /** \brief Slice type.
+     *  Range: 0..2, 5..7, i.e. no switching slices.
+     */
+    unsigned char   slice_type;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned char   pic_parameter_set_id;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned short  idr_pic_id;
+
+    /** @name If pic_order_cnt_type == 0 */
+    /**@{*/
+    /** \brief The picture order count modulo MaxPicOrderCntLsb. */
+    unsigned short  pic_order_cnt_lsb;
+    /** \brief Valid if \c pic_order_present_flag and this is a bottom field. */
+    int             delta_pic_order_cnt_bottom;
+    /**@}*/
+    /** @name If pic_order_cnt_type == 1 && !delta_pic_order_always_zero_flag */
+    /**@{*/
+    /** \brief [0]: top, [1]: bottom. */
+    int             delta_pic_order_cnt[2];
+    /**@}*/
+
+    /** @name If slice_type == B */
+    /**@{*/
+    unsigned char   direct_spatial_mv_pred_flag;
+    /**@}*/
+
+    /** @name If slice_type == P */
+    /**@{*/
+    /** \brief Specifies if
+     * \ref _VAEncPictureParameterBufferH264::num_ref_idx_l0_active_minus1 or
+     * \ref _VAEncPictureParameterBufferH264::num_ref_idx_l1_active_minus1 are
+     * overriden by the values for this slice.
+     */
+    unsigned char   num_ref_idx_active_override_flag;
+    /** \brief Maximum reference index for reference picture list 0.
+     *  Range: 0 to 31, inclusive.
+     */
+    unsigned char   num_ref_idx_l0_active_minus1;
+    /** \brief Maximum reference index for reference picture list 1.
+     *  Range: 0 to 31, inclusive.
+     */
+    unsigned char   num_ref_idx_l1_active_minus1;
+    /** \brief Reference picture list 0 (for P slices). */
+    VAPictureH264   RefPicList0[32];
+    /** \brief Reference picture list 1 (for B slices). */
+    VAPictureH264   RefPicList1[32];
+    /**@}*/
+
+    /** @name pred_weight_table() */
+    /**@{*/
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned char   luma_log2_weight_denom;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned char   chroma_log2_weight_denom;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned char   luma_weight_l0_flag;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    signed short    luma_weight_l0[32];
+    /** \brief Same as the H.264 bitstream syntax element. */
+    signed short    luma_offset_l0[32];
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned char   chroma_weight_l0_flag;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    signed short    chroma_weight_l0[32][2];
+    /** \brief Same as the H.264 bitstream syntax element. */
+    signed short    chroma_offset_l0[32][2];
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned char   luma_weight_l1_flag;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    signed short    luma_weight_l1[32];
+    /** \brief Same as the H.264 bitstream syntax element. */
+    signed short    luma_offset_l1[32];
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned char   chroma_weight_l1_flag;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    signed short    chroma_weight_l1[32][2];
+    /** \brief Same as the H.264 bitstream syntax element. */
+    signed short    chroma_offset_l1[32][2];
+    /**@}*/
+
+    /** \brief Range: 0 to 2, inclusive. */
+    unsigned char   cabac_init_idc;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    signed char     slice_qp_delta;
+    /** @name If deblocking_filter_control_present_flag */
+    /**@{*/
+    /** \brief Range: 0 to 2, inclusive. */
+    unsigned char   disable_deblocking_filter_idc;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    signed char     slice_alpha_c0_offset_div2;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    signed char     slice_beta_offset_div2;
+    /**@}*/
+} VAEncSliceParameterBufferH264;
+
+/**
+ * @name Macroblock neighbour availability bits
+ *
+ * \anchor api_enc_h264_mb_pred_avail_bits
+ * Definitions for macroblock neighbour availability bits used in
+ * intra prediction mode (non MBAFF only).
+ *
+ * @{
+ */
+/** \brief References macroblock in the top-left corner. */
+#define VA_MB_PRED_AVAIL_TOP_LEFT         (1 << 2)
+/** \brief References macroblock above the current macroblock. */
+#define VA_MB_PRED_AVAIL_TOP              (1 << 4)
+/** \brief References macroblock in the top-right corner. */
+#define VA_MB_PRED_AVAIL_TOP_RIGHT        (1 << 3)
+/** \brief References macroblock on the left of the current macroblock. */
+#define VA_MB_PRED_AVAIL_LEFT             (1 << 6)
+/**@}*/
+
+/**
+ * \brief Macroblock parameter for H.264 encoding in baseline, main & high 
+ * profiles.
+ *
+ * This structure holds per-macroblock information. The buffer must be
+ * allocated with as many elements (macroblocks) as necessary to fit
+ * the slice to be encoded. Besides, the per-macroblock records must
+ * be written in a strict raster order and with no gap. i.e. every
+ * macroblock, regardless of its type, shall have an entry.
+ */
+typedef struct _VAEncMacroblockParameterBufferH264 {
+    /**
+     * \brief Quantization parameter.
+     *
+     * Requested quantization parameter. Range: 0 to 51, inclusive.
+     * If \ref qp is set to 0xff, then the actual value is derived
+     * from the slice-level value: \c pic_init_qp + \c slice_qp_delta.
+     */
+    unsigned char   qp;
+
+    union {
+        /** @name Data for intra macroblock */
+        /**@{*/
+        struct {
+            union {
+                /**
+                 * \brief Flag specified to override MB neighbour
+                 * availability bits from VME stage.
+                 *
+                 * This flag specifies that macroblock neighbour
+                 * availability bits from the VME stage are overriden
+                 * by the \ref pred_avail_flags hereunder.
+                 */
+                unsigned int    pred_avail_override_flag        : 1;
+                /**
+                 * \brief Bitwise representation of which macroblocks
+                 * are available for intra prediction.
+                 *
+                 * If the slice is intra-coded, this field represents
+                 * the macroblocks available for intra prediction.
+                 * See \ref api_enc_h264_mb_pred_avail_bits
+                 * "macroblock neighbour availability" bit definitions.
+                 */
+                unsigned int    pred_avail_flags                : 8;
+            } bits;
+            unsigned int value;
+        } intra_fields;
+        /**@}*/
+
+        /** @name Data for inter macroblock */
+        /**@{*/
+        struct {
+            union {
+            } bits;
+            unsigned int value;
+        } inter_fields;
+        /**@}*/
+    } info;
+} VAEncMacroblockParameterBufferH264;
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* VA_ENC_H264_H */
--- /dev/null
+++ src/gallium/state_trackers/va/va/va_enc_hevc.h
@@ -0,0 +1,701 @@
+/*
+ * Copyright (c) 2007-2014 Intel Corporation. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/**
+ * \file va_enc_hevc.h
+ * \brief The HEVC encoding API
+ *
+ * This file contains the \ref api_enc_hevc "HEVC encoding API".
+ *
+ */
+
+#ifndef VA_ENC_HEVC_H
+#define VA_ENC_HEVC_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+
+/**
+ * \defgroup api_enc_hevc HEVC encoding API
+ *
+ * @{
+ */
+
+/**
+ * @name Picture flags
+ *
+ * Those flags flags are meant to signal when a picture marks the end
+ * of a sequence, a stream, or even both at once.
+ *
+ * @{
+ */
+/**
+ * \brief Marks the last picture in the sequence.
+ *
+ * i.e. the driver appends \c end_of_seq() NAL unit to the encoded frame.
+ */
+#define HEVC_LAST_PICTURE_EOSEQ     0x01
+/**
+ * \brief Marks the last picture in the stream.
+ *
+ * i.e. the driver appends \c end_of_stream() NAL unit to the encoded frame.
+ */
+#define HEVC_LAST_PICTURE_EOSTREAM  0x02
+/**@}*/
+
+/**
+ * \brief Packed header types specific to HEVC encoding.
+ *
+ * Types of packed headers generally used for HEVC encoding. Each
+ * associated packed header data buffer shall contain the start code
+ * prefix 0x000001 followed by the complete NAL unit, thus also
+ * including the \c nal_unit_type.
+ *
+ * Note: the start code prefix can contain an arbitrary number of leading
+ * zeros. The driver will skip them for emulation prevention bytes insertion,
+ * if necessary.
+ */
+typedef enum {
+    /**
+     * \brief Packed Video Parameter Set (VPS).
+     *
+     * The corresponding packed header data buffer shall contain the
+     * complete video_parameter_set_rbsp() syntax element.
+     *
+     * Note: packed \c nal_unit_type shall be equal to 32.
+     */
+    VAEncPackedHeaderHEVC_VPS   = VAEncPackedHeaderSequence,
+    /**
+     * \brief Packed Sequence Parameter Set (SPS).
+     *
+     * The corresponding packed header data buffer shall contain the
+     * complete seq_parameter_set_rbsp() syntax element.
+     *
+     * Note: packed \c nal_unit_type shall be equal to 33.
+     */
+    VAEncPackedHeaderHEVC_SPS   = VAEncPackedHeaderSequence,
+    /**
+     * \brief Packed Picture Parameter Set (PPS).
+     *
+     * The corresponding packed header data buffer shall contain the
+     * complete pic_parameter_set_rbsp() syntax element.
+     *
+     * Note: packed \c nal_unit_type shall be equal to 34.
+     */
+    VAEncPackedHeaderHEVC_PPS   = VAEncPackedHeaderPicture,
+    /**
+     * \brief Packed slice header.
+     *
+     * The corresponding packed header data buffer shall contain the
+     * \c slice_header() syntax element only, along with any start
+     * code prefix and NAL unit type preceeding it. i.e. this means
+     * that the buffer does not contain any of the \c slice_data() or
+     * the \c rbsp_slice_trailing_bits().
+     *
+     * Note: packed \c nal_unit_type shall be equal to 0 to 9 (non-IRAP
+     * picture), or 16 to 21 (IRAP picture).
+     */
+    VAEncPackedHeaderHEVC_Slice = VAEncPackedHeaderSlice,
+    /**
+     * \brief Packed Supplemental Enhancement Information (SEI).
+     *
+     * The corresponding packed header data buffer shall contain the
+     * complete sei_rbsp() syntax element, thus including several
+     * sei_message() elements if necessary.
+     *
+     * Note: packed \c nal_unit_type shall be equal to 39 or 40.
+     */
+    VAEncPackedHeaderHEVC_SEI   = (VAEncPackedHeaderMiscMask | 1),
+} VAEncPackedHeaderTypeHEVC;
+
+/**
+ * \brief Sequence parameter for HEVC encoding in main & main 10
+ * profiles.
+ *
+ * This structure holds information for \c seq_parameter_set_data() as
+ * defined by the HEVC specification.
+ *
+ * If packed sequence headers mode is used, i.e. if the encoding
+ * pipeline was configured with the #VA_ENC_PACKED_HEADER_SEQUENCE
+ * flag, then the driver expects two more buffers to be provided to
+ * the same \c vaRenderPicture() as this buffer:
+ * - a #VAEncPackedHeaderParameterBuffer with type set to
+ *   VAEncPackedHeaderType::VAEncPackedHeaderSequence ;
+ * - a #VAEncPackedHeaderDataBuffer which holds the actual packed
+ *   header data.
+ *
+ * If \c seq_scaling_matrix_present_flag is set to \c 1, then a
+ * #VAQMatrixBufferHEVC buffer shall also be provided within the same
+ * \c vaRenderPicture() call as this sequence parameter buffer.
+ */
+typedef struct _VAEncSequenceParameterBufferHEVC {
+    /** \brief Same as the HEVC bitstream syntax element.
+     *  value range [1..2].
+     */
+    uint8_t     general_profile_idc;
+    /** \brief Same as the HEVC bitstream syntax element.
+     *  general_level_idc shall be set equal to a value of 30 times the level
+     *  numbers allowed [1, 2, 2.1, 3, 3.1, 4, 4.1, 5, 5.1, 5.2, 6, 6.1, 6.2]
+     */
+    uint8_t     general_level_idc;
+    /** \brief Same as the HEVC bitstream syntax element.
+     *  Only value 0 is allowed for level value below 4, exclusive.
+     */
+    uint8_t     general_tier_flag;
+    /** \brief Period between I frames. */
+    uint32_t    intra_period;
+    /** \brief Period between IDR frames. */
+    uint32_t    intra_idr_period;
+    /** \brief Period between I/P frames. */
+    uint32_t    ip_period;
+    /**
+     * \brief Initial bitrate set for this sequence in CBR or VBR modes.
+     *
+     * This field represents the initial bitrate value for this
+     * sequence if CBR or VBR mode is used, i.e. if the encoder
+     * pipeline was created with a #VAConfigAttribRateControl
+     * attribute set to either \ref VA_RC_CBR or \ref VA_RC_VBR.
+     *
+     * The bitrate can be modified later on through
+     * #VAEncMiscParameterRateControl buffers.
+     */
+    uint32_t    bits_per_second;
+    /** \brief Picture width in pixel samples.
+     *  Its value must be multiple of min CU size.
+     */
+    uint16_t    pic_width_in_luma_samples;
+    /** \brief Picture height in pixel samples.
+     *  Its value must be multiple of min CU size.
+     */
+    uint16_t    pic_height_in_luma_samples;
+
+    union {
+        struct {
+            /** \brief Same as the HEVC bitstream syntax element. */
+            uint32_t    chroma_format_idc                              : 2;
+            /** \brief Same as the HEVC bitstream syntax element. */
+            uint32_t    separate_colour_plane_flag                     : 1;
+            /** \brief Same as the HEVC bitstream syntax element. */
+            uint32_t    bit_depth_luma_minus8                          : 3;
+            /** \brief Same as the HEVC bitstream syntax element. */
+            uint32_t    bit_depth_chroma_minus8                        : 3;
+            /** \brief Same as the HEVC bitstream syntax element. */
+            uint32_t    scaling_list_enabled_flag                      : 1;
+            /** \brief Same as the HEVC bitstream syntax element. */
+            uint32_t    strong_intra_smoothing_enabled_flag            : 1;
+            /** \brief Same as the HEVC bitstream syntax element. */
+            uint32_t    amp_enabled_flag                               : 1;
+            /** \brief Same as the HEVC bitstream syntax element. */
+            uint32_t    sample_adaptive_offset_enabled_flag            : 1;
+            /** \brief Same as the HEVC bitstream syntax element. */
+            uint32_t    pcm_enabled_flag                               : 1;
+            /** \brief Same as the HEVC bitstream syntax element. */
+            uint32_t    pcm_loop_filter_disabled_flag                  : 1;
+            /** \brief Same as the HEVC bitstream syntax element. */
+            uint32_t    sps_temporal_mvp_enabled_flag                  : 1;
+
+            uint32_t    reserved_bits                                  : 16;
+        } bits;
+        uint32_t value;
+    } seq_fields;
+
+    /** \brief Same as the HEVC bitstream syntax element.
+     *  value range [0..3]
+     */
+    uint8_t     log2_min_luma_coding_block_size_minus3;
+
+    /** \brief Same as the HEVC bitstream syntax element.
+     */
+    uint8_t     log2_diff_max_min_luma_coding_block_size;
+
+    /** \brief Same as the HEVC bitstream syntax element.
+     *  value range [0..3]
+     */
+    uint8_t     log2_min_transform_block_size_minus2;
+
+    /** \brief Same as the HEVC bitstream syntax element.
+     */
+    uint8_t     log2_diff_max_min_transform_block_size;
+
+    /** \brief Same as the HEVC bitstream syntax element.
+     *  value range [2]
+     */
+    uint8_t     max_transform_hierarchy_depth_inter;
+
+    /** \brief Same as the HEVC bitstream syntax element.
+     *  value range [2]
+     */
+    uint8_t     max_transform_hierarchy_depth_intra;
+
+    /** \brief Same as the HEVC bitstream syntax element. */
+    uint32_t    pcm_sample_bit_depth_luma_minus1;
+
+    /** \brief Same as the HEVC bitstream syntax element. */
+    uint32_t    pcm_sample_bit_depth_chroma_minus1;
+
+    /** \brief Same as the HEVC bitstream syntax element. */
+    uint32_t    log2_min_pcm_luma_coding_block_size_minus3;
+
+    /** \brief Derived from the HEVC bitstream syntax element.
+    *  log2_min_pcm_luma_coding_block_size_minus3 +
+    *  log2_diff_max_min_pcm_luma_coding_block_size
+    */
+    uint32_t    log2_max_pcm_luma_coding_block_size_minus3;
+
+    /** @name VUI parameters (optional) */
+    /**@{*/
+    /** \brief Same as the HEVC bitstream syntax element. */
+    uint8_t     vui_parameters_present_flag;
+    union {
+        struct {
+            /** \brief Same as the HEVC bitstream syntax element. */
+            uint32_t    aspect_ratio_info_present_flag                 : 1;
+            /** \brief Same as the HEVC bitstream syntax element. */
+            uint32_t    neutral_chroma_indication_flag                 : 1;
+            /** \brief Same as the HEVC bitstream syntax element. */
+            uint32_t    field_seq_flag                                 : 1;
+            /** \brief Same as the HEVC bitstream syntax element. */
+            uint32_t    vui_timing_info_present_flag                   : 1;
+            /** \brief Same as the HEVC bitstream syntax element. */
+            uint32_t    bitstream_restriction_flag                     : 1;
+            /** \brief Same as the HEVC bitstream syntax element. */
+            uint32_t    tiles_fixed_structure_flag                     : 1;
+            /** \brief Same as the HEVC bitstream syntax element. */
+            uint32_t    motion_vectors_over_pic_boundaries_flag        : 1;
+            /** \brief Same as the HEVC bitstream syntax element. */
+            uint32_t    restricted_ref_pic_lists_flag                  : 1;
+            /** \brief Range: 0 to 16, inclusive. */
+            uint32_t    log2_max_mv_length_horizontal                  : 5;
+            /** \brief Range: 0 to 16, inclusive. */
+            uint32_t    log2_max_mv_length_vertical                    : 5;
+        } bits;
+        uint32_t value;
+    } vui_fields;
+    /** \brief Same as the HEVC bitstream syntax element. */
+    uint8_t     aspect_ratio_idc;
+    /** \brief Same as the HEVC bitstream syntax element. */
+    uint32_t    sar_width;
+    /** \brief Same as the HEVC bitstream syntax element. */
+    uint32_t    sar_height;
+    /** \brief Same as the HEVC bitstream syntax element. */
+    uint32_t    vui_num_units_in_tick;
+    /** \brief Same as the HEVC bitstream syntax element. */
+    uint32_t    vui_time_scale;
+    /** \brief Same as the HEVC bitstream syntax element. */
+    uint16_t    min_spatial_segmentation_idc;
+    /** \brief Same as the HEVC bitstream syntax element. */
+    uint8_t     max_bytes_per_pic_denom;
+    /** \brief Same as the HEVC bitstream syntax element. */
+    uint8_t     max_bits_per_min_cu_denom;
+    /**@}*/
+} VAEncSequenceParameterBufferHEVC;
+
+/****************************
+ * HEVC data structures
+ ****************************/
+/**
+ * \brief Picture parameter for HEVC encoding in main & main 10
+ * profiles.
+ *
+ * This structure holds information for \c pic_parameter_set_rbsp() as
+ * defined by the HEVC specification.
+ *
+ * If packed picture headers mode is used, i.e. if the encoding
+ * pipeline was configured with the #VA_ENC_PACKED_HEADER_PICTURE
+ * flag, then the driver expects two more buffers to be provided to
+ * the same \c vaRenderPicture() as this buffer:
+ * - a #VAEncPackedHeaderParameterBuffer with type set to
+ *   VAEncPackedHeaderType::VAEncPackedHeaderPicture ;
+ * - a #VAEncPackedHeaderDataBuffer which holds the actual packed
+ *   header data.
+ *
+ * If \c pic_scaling_matrix_present_flag is set to \c 1, then a
+ * #VAQMatrixBufferHEVC buffer shall also be provided within the same
+ * \c vaRenderPicture() call as this picture parameter buffer.
+ */
+typedef struct _VAEncPictureParameterBufferHEVC {
+    /**
+     * \brief Information about the picture to be encoded.
+     *
+     * See #VAPictureHEVC for further description of each field.
+     * Note that decoded_curr_pic.picture_id represents the reconstructed
+     * (decoded) picture. User provides a scratch VA surface ID here.
+     * Long term reference and RPS related fields should be set to 0
+     * and ignored.
+     */
+    VAPictureHEVC   decoded_curr_pic;
+    /**
+     * \brief Decoded Picture Buffer (DPB).
+     *
+     * This array represents the list of reconstructed (decoded)
+     * frames used as reference. It is important to keep track of
+     * reconstructed frames so that they can be used later on as
+     * reference for P or B-frames encoding.
+     */
+    VAPictureHEVC   reference_frames[15];
+    /**
+     * \brief Output encoded bitstream.
+     *
+     * \ref coded_buf has type #VAEncCodedBufferType. It should be
+     * large enough to hold the compressed NAL slice and possibly VPS, SPS
+     * and PPS NAL units, and other NAL units such as SEI.
+     */
+    VABufferID      coded_buf;
+
+    /** \brief collocated reference picture buffer index of ReferenceFrames[].
+     * Please note it is different from HEVC syntac element collocated_ref_idx.
+     * When  the HEVC syntax element slice_temporal_mvp_enable_flag takes value 0,
+     * collocated_ref_pic_index should take value 0xFF. .
+     * Range: [0..14, 0xFF]
+     */
+    uint8_t         collocated_ref_pic_index;
+
+    /**
+     * \brief OR'd flags describing whether the picture is the last one or not.
+     *
+     * This fields holds 0 if the picture to be encoded is not the last
+     * one in the stream or sequence. Otherwise, it is a combination of
+     * \ref HEVC_LAST_PICTURE_EOSEQ or \ref HEVC_LAST_PICTURE_EOSTREAM.
+     */
+    uint8_t         last_picture;
+
+    /** \brief \c init_qp_minus26 + 26. */
+    uint8_t         pic_init_qp;
+
+    /** \brief Corresponds to HEVC syntax element of the same name. */
+    uint8_t         diff_cu_qp_delta_depth;
+
+    /** \brief Corresponds to HEVC syntax element of the same name. */
+    int8_t          pps_cb_qp_offset;
+
+    /** \brief Corresponds to HEVC syntax element of the same name. */
+    int8_t          pps_cr_qp_offset;
+
+    /** \brief Corresponds to HEVC syntax element of the same name. */
+    uint8_t         num_tile_columns_minus1;
+
+    /** \brief Corresponds to HEVC syntax element of the same name. */
+    uint8_t         num_tile_rows_minus1;
+
+    /** \brief Corresponds to HEVC syntax element of the same name. */
+    uint8_t         column_width_minus1[19];
+
+    /** \brief Corresponds to HEVC syntax element of the same name. */
+    uint8_t         row_height_minus1[21];
+
+    /** \brief Corresponds to HEVC syntax element of the same name. */
+    uint8_t         log2_parallel_merge_level_minus2;
+
+    /** \brief Application may set the CTU bit size limit based on
+     *  spec requirement (A.3.2), or other value for special purpose.
+     *  If the value is set 0, no bit size limit is checked.
+     */
+    uint8_t         ctu_max_bitsize_allowed;
+
+    /** \brief Maximum reference index for reference picture list 0.
+     *   value range: [0..14].
+     */
+    uint8_t         num_ref_idx_l0_default_active_minus1;
+
+    /** \brief Maximum reference index for reference picture list 1.
+     *  value range: [0..14].
+     */
+    uint8_t         num_ref_idx_l1_default_active_minus1;
+
+    /** \brief PPS header
+     *  Used by GPU to generate new slice headers in slice size control.
+     *  value range: [0..63].
+     */
+    uint8_t         slice_pic_parameter_set_id;
+
+    /** \brief NAL unit type
+     *  Used by GPU to generate new slice headers in slice size control.
+     *  value range: [0..63].
+     */
+    uint8_t         nal_unit_type;
+
+    union {
+        struct {
+            /** \brief Is picture an IDR picture? */
+            uint32_t    idr_pic_flag                                   : 1;
+            /** \brief Picture type.
+             *  I  - 1;
+             *  P  - 2;
+             *  B  - 3;
+             *  B1 - 4;
+             *  B2 - 5;
+             * B1 and B2 are frame types for hierachical B, explanation
+             * can refer to num_b_in_gop[].
+             */
+            uint32_t    coding_type                                    : 3;
+            /** \brief Is picture a reference picture? */
+            uint32_t    reference_pic_flag                             : 1;
+            /** \brief Corresponds to HEVC syntax element of the same name. */
+            uint32_t    dependent_slice_segments_enabled_flag          : 1;
+            /** \brief Corresponds to HEVC syntax element of the same name. */
+            uint32_t    sign_data_hiding_enabled_flag                  : 1;
+            /** \brief Corresponds to HEVC syntax element of the same name. */
+            uint32_t    constrained_intra_pred_flag                    : 1;
+            /** \brief Corresponds to HEVC syntax element of the same name. */
+            uint32_t    transform_skip_enabled_flag                    : 1;
+            /** \brief Corresponds to HEVC syntax element of the same name. */
+            uint32_t    cu_qp_delta_enabled_flag	               : 1;
+            /** \brief Corresponds to HEVC syntax element of the same name. */
+            uint32_t    weighted_pred_flag                             : 1;
+            /** \brief Corresponds to HEVC syntax element of the same name. */
+            uint32_t    weighted_bipred_flag                           : 1;
+            /** \brief Corresponds to HEVC syntax element of the same name. */
+            uint32_t    transquant_bypass_enabled_flag                 : 1;
+            /** \brief Corresponds to HEVC syntax element of the same name. */
+            uint32_t    tiles_enabled_flag                             : 1;
+            /** \brief Corresponds to HEVC syntax element of the same name. */
+            uint32_t    entropy_coding_sync_enabled_flag               : 1;
+            /** \brief Corresponds to HEVC syntax element of the same name. */
+            uint32_t    loop_filter_across_tiles_enabled_flag          : 1;
+            /** \brief Corresponds to HEVC syntax element of the same name. */
+            uint32_t    pps_loop_filter_across_slices_enabled_flag     : 1;
+            /** \brief A combination of HEVC syntax element of
+             *  sps_scaling_list_data_present_flag and
+             *  pps_scaling_list_data_present_flag
+             *  when scaling_list_enable_flag is 0, it must be 0.
+             */
+            uint32_t    scaling_list_data_present_flag                 : 1;
+            /** \brief indicate the current picture contains significant
+             *  screen contents (text, characters, etc.) or animated image.
+             *  GPU may want to treat them differently from normal video.
+             *  For example, encoder may choose a small transform unit size
+             *  and may use transform skip mode.
+             */
+            uint32_t    screen_content_flag                            : 1;
+            /**
+             *  When either weighted_pred_flag or weighted_bipred_flag is
+             *  turned on, the flag enable_gpu_weighted_prediction requests
+             *  GPU to determine weighted prediction factors. In this case,
+             *  the following parameters in slice control data structure
+             *  shall be ignored:
+             *  luma_log2_weight_denom, delta_chroma_log2_weight_denom,
+             *  luma_offset_l0[15], luma_offset_l1[15],
+             *  delta_luma_weight_l0[15], delta_luma_weight_l1[15],
+             *  chroma_offset_l0[15][2], chroma_offset_l1[15][2],
+             *  and delta_chroma_weight_l0[15][2], delta_chroma_weight_l1[15][2].
+             */
+            uint32_t    enable_gpu_weighted_prediction                 : 1;
+            /** \brief HEVC syntax element in slice segment header
+             *  GPU uses it to generate new slice headers in slice size control.
+             */
+            uint32_t    no_output_of_prior_pics_flag                   : 1;
+            uint32_t    reserved                                       : 11;
+        } bits;
+        uint32_t        value;
+    } pic_fields;
+} VAEncPictureParameterBufferHEVC;
+
+/**
+ * \brief Slice parameter for HEVC encoding in main & main 10 profiles.
+ *
+ * This structure holds information for \c
+ * slice_segment_layer_rbsp() as defined by the HEVC
+ * specification.
+ *
+ * If packed slice headers mode is used, i.e. if the encoding
+ * pipeline was configured with the #VA_ENC_PACKED_HEADER_SLICE
+ * flag, then the driver expects two more buffers to be provided to
+ * the same \c vaRenderPicture() as this buffer:
+ * - a #VAEncPackedHeaderParameterBuffer with type set to
+ *   VAEncPackedHeaderType::VAEncPackedHeaderSlice ;
+ * - a #VAEncPackedHeaderDataBuffer which holds the actual packed
+ *   header data.
+ *
+ */
+typedef struct _VAEncSliceParameterBufferHEVC {
+    /** \brief Starting CTU address for this slice. */
+    uint32_t        slice_segment_address;
+    /** \brief Number of CTUs in this slice. */
+    uint32_t        num_ctu_in_slice;
+
+    /** \brief Slice type.
+     *  Corresponds to HEVC syntax element of the same name.
+     */
+    uint8_t         slice_type;
+    /** \brief Same as the HEVC bitstream syntax element. */
+    uint8_t         slice_pic_parameter_set_id;
+
+    /** \brief Maximum reference index for reference picture list 0.
+     *  Range: 0 to 14, inclusive.
+     */
+    uint8_t         num_ref_idx_l0_active_minus1;
+    /** \brief Maximum reference index for reference picture list 1.
+     *  Range: 0 to 14, inclusive.
+     */
+    uint8_t         num_ref_idx_l1_active_minus1;
+    /** \brief Reference picture list 0 (for P slices). */
+    VAPictureHEVC   ref_pic_list0[15];
+    /** \brief Reference picture list 1 (for B slices). */
+    VAPictureHEVC   ref_pic_list1[15];
+    /**@}*/
+
+    /** @name pred_weight_table() */
+    /**@{*/
+    /** \brief Same as the HEVC bitstream syntax element. */
+    uint8_t         luma_log2_weight_denom;
+    /** \brief Same as the HEVC bitstream syntax element. */
+    int8_t          delta_chroma_log2_weight_denom;
+    /** \brief Same as the HEVC bitstream syntax element. */
+    int8_t          delta_luma_weight_l0[15];
+    /** \brief Same as the HEVC bitstream syntax element. */
+    int8_t          luma_offset_l0[15];
+    /** \brief Same as the HEVC bitstream syntax element. */
+    int8_t          delta_chroma_weight_l0[15][2];
+    /** \brief Same as the HEVC spec variable ChromaOffsetL0[]. */
+    int8_t          chroma_offset_l0[15][2];
+    /** \brief Same as the HEVC bitstream syntax element. */
+    int8_t          delta_luma_weight_l1[15];
+    /** \brief Same as the HEVC bitstream syntax element. */
+    int8_t          luma_offset_l1[15];
+    /** \brief Same as the HEVC bitstream syntax element. */
+    int8_t          delta_chroma_weight_l1[15][2];
+    /** \brief Same as the HEVC spec variable ChromaOffsetL1[]. */
+    int8_t          chroma_offset_l1[15][2];
+    /**@}*/
+
+    /** \brief Corresponds to HEVC spec variable MaxNumMergeCand.
+     *  Range: [1..5].
+     */
+    uint8_t         max_num_merge_cand;
+
+    /** \brief Same as the HEVC bitstream syntax element. */
+    int8_t          slice_qp_delta;
+
+    /** \brief Same as the HEVC bitstream syntax element. */
+    int8_t          slice_cb_qp_offset;
+
+    /** \brief Same as the HEVC bitstream syntax element. */
+    int8_t          slice_cr_qp_offset;
+
+    /** \brief Same as the HEVC bitstream syntax element. */
+    int8_t          slice_beta_offset_div2;
+
+    /** \brief Same as the HEVC bitstream syntax element. */
+    int8_t          slice_tc_offset_div2;
+
+    union {
+        struct {
+            /** \brief Indicates if current slice is the last one in picture */
+            uint32_t    last_slice_of_pic_flag                         : 1;
+            /** \brief Corresponds to HEVC syntax element of the same name */
+            uint32_t    dependent_slice_segment_flag                   : 1;
+            /** \brief Corresponds to HEVC syntax element of the same name */
+            uint32_t    colour_plane_id                                : 2;
+            /** \brief Corresponds to HEVC syntax element of the same name. */
+            uint32_t    slice_temporal_mvp_enabled_flag                : 1;
+            /** \brief Corresponds to HEVC syntax element of the same name. */
+            uint32_t    slice_sao_luma_flag                            : 1;
+            /** \brief Corresponds to HEVC syntax element of the same name. */
+            uint32_t    slice_sao_chroma_flag                          : 1;
+            /** \brief Corresponds to HEVC syntax element of the same name.
+             *  if this flag is set to 0, num_ref_idx_l0_active_minus1 should be
+             *  equal to num_ref_idx_l0_default_active_minus1
+             *  as well as for that for l1.
+             */
+            uint32_t    num_ref_idx_active_override_flag               : 1;
+            /** \brief Corresponds to HEVC syntax element of the same name. */
+            uint32_t    mvd_l1_zero_flag                               : 1;
+            /** \brief Corresponds to HEVC syntax element of the same name. */
+            uint32_t    cabac_init_flag        	                    : 1;
+            /** \brief Corresponds to HEVC syntax element of the same name. */
+            uint32_t    slice_deblocking_filter_disabled_flag          : 2;
+            /** \brief Corresponds to HEVC syntax element of the same name. */
+            uint32_t    slice_loop_filter_across_slices_enabled_flag   : 1;
+            /** \brief Corresponds to HEVC syntax element of the same name. */
+            uint32_t    collocated_from_l0_flag                        : 1;
+        } bits;
+        uint32_t        value;
+    } slice_fields;
+    /**@}*/
+} VAEncSliceParameterBufferHEVC;
+
+/**
+ * \brief HEVC Quantization Matrix Buffer Structure
+ *
+ * This structure is sent once per frame,
+ * and only when scaling_list_enabled_flag = 1 and scaling_list_data_present_flag = 1.
+ * Only when scaling_list_data_present_flag = 1, app still
+ * needs to send in this structure. When scaling_list_enabled_flag = 1 and
+ * scaling_list_data_present_flag = 0, driver is responsible to generate
+ * the default scaling list values.
+ *
+ * Matrix entries are in raster scan order which follows HEVC spec.
+ */
+typedef struct _VAQMatrixBufferHEVC
+{
+    /**
+     * \brief scaling lists,
+     * corresponds to same HEVC spec syntax element
+     * ScalingList[ i ][ MatrixID ][ j ].
+     *
+     * \brief 4x4 scaling,
+     */
+    uint8_t             scaling_lists_4x4[3][2][16];
+    /**
+     * \brief 8x8 scaling,
+     */
+    uint8_t             scaling_lists_8x8[3][2][64];
+    /**
+     * \brief 16x16 scaling,
+     * correspongs i = 2, MatrixID is in the range of 0 to 5,
+     * inclusive. And j is in the range of 0 to 63, inclusive.
+     */
+    uint8_t             scaling_lists_16x16[3][2][64];
+    /**
+     * \brief 32x32 scaling,
+     * correspongs i = 3, MatrixID is in the range of 0 to 1,
+     * inclusive. And j is in the range of 0 to 63, inclusive.
+     */
+    uint8_t             scaling_lists_32x32[2][64];
+    /**
+     * \brief DC values of the 16x16 scaling lists,
+     * corresponds to HEVC spec syntax
+     * scaling_list_dc_coef_minus8[ sizeID - 2 ][ matrixID ] + 8
+     * with sizeID = 2 and matrixID in the range of 0 to 5, inclusive.
+     */
+    uint8_t             scaling_list_dc_16x16[3][2];
+    /**
+     * \brief DC values of the 32x32 scaling lists,
+     * corresponds to HEVC spec syntax
+     * scaling_list_dc_coef_minus8[ sizeID - 2 ][ matrixID ] + 8
+     * with sizeID = 3 and matrixID in the range of 0 to 1, inclusive.
+     */
+    uint8_t             scaling_list_dc_32x32[2];
+} VAQMatrixBufferHEVC;
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* VA_ENC_HEVC_H */
--- /dev/null
+++ src/gallium/state_trackers/va/va/va_enc_jpeg.h
@@ -0,0 +1,156 @@
+/*
+ * Copyright (c) 2007-2013 Intel Corporation. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/**
+ * \file va_enc_jpeg.h
+ * \brief JPEG encoding API
+ *
+ * This file contains the \ref api_enc_jpeg "JPEG encoding API".
+ */
+
+#ifndef VA_ENC_JPEG_H
+#define VA_ENC_JPEG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \defgroup api_enc_jpeg JPEG encoding API
+ *
+ * @{
+ */
+
+/**
+ * \brief JPEG Encoding Picture Parameter Buffer Structure
+ *
+ * This structure conveys picture level parameters.
+ *
+ */
+typedef struct  _VAEncPictureParameterBufferJPEG
+{
+    /** \brief holds reconstructed picture. */
+    VASurfaceID reconstructed_picture;
+    /** \brief picture width. */
+    unsigned short picture_width;
+    /** \brief picture height. */
+    unsigned short picture_height;
+    /** \brief holds coded data. */
+    VABufferID coded_buf;
+
+    /** 
+     * \brief pic_flags
+     *
+     */
+    union {
+        struct {
+            /** 
+             * \brief profile: 
+             * 0 - Baseline, 1 - Extended, 2 - Lossless, 3 - Hierarchical
+             */ 
+            unsigned int profile     : 2;
+            /** 
+             * \brief progressive: 
+             * 0 - sequential, 1 - extended, 2 - progressive
+             */ 
+            unsigned int progressive : 1;
+            /** 
+             * \brief huffman: 
+             * 0 - arithmetic, 1 - huffman
+             */ 
+            unsigned int huffman     : 1;
+            /** 
+             * \brief interleaved: 
+             * 0 - non interleaved, 1 - interleaved
+             */ 
+            unsigned int interleaved : 1;
+            /** 
+             * \brief differential: 
+             * 0 - non differential, 1 - differential
+             */ 
+            unsigned int differential   : 1;
+        } bits;
+        unsigned int value;
+    } pic_flags;
+
+    /** \brief number of bits per sample. */
+    unsigned char    sample_bit_depth;
+    /** \brief total number of scans in image. */
+    unsigned char    num_scan;
+    /** \brief number of image components in frame. */
+    unsigned short   num_components;
+    /** \brief Component identifier (Ci). */
+    unsigned char    component_id[4];
+    /** \brief Quantization table selector (Tqi). */
+    unsigned char    quantiser_table_selector[4];
+    /** \brief number from 1 to 100 that specifies quality of image. */
+    unsigned char    quality;
+
+} VAEncPictureParameterBufferJPEG;
+
+
+/**
+ * \brief Slice parameter for JPEG encoding. 
+ *
+ * This structure conveys slice (scan) level parameters.
+ *
+ */
+typedef struct _VAEncSliceParameterBufferJPEG {
+    /** \brief Restart interval definition (Ri). */
+    unsigned short    restart_interval;
+    /** \brief number of image components in a scan. */
+    unsigned short    num_components;
+    struct {
+        /** \brief Scan component selector (Csj). */
+        unsigned char   component_selector;
+        /** \brief DC entropy coding table selector (Tdj). */
+        unsigned char   dc_table_selector;
+        /** \brief AC entropy coding table selector (Taj). */
+        unsigned char   ac_table_selector;
+    } components[4];
+} VAEncSliceParameterBufferJPEG;
+
+/**
+ * \brief Quantization table for JPEG encoding.
+ *
+ */
+typedef struct _VAQMatrixBufferJPEG
+{
+    /** \brief load luma quantization table. */
+    int load_lum_quantiser_matrix;
+    /** \brief load chroma quantization table. */
+    int load_chroma_quantiser_matrix;
+    /** \brief luma quantization table. */
+    unsigned char lum_quantiser_matrix[64];
+    /** \brief chroma quantization table. */
+    unsigned char chroma_quantiser_matrix[64];
+} VAQMatrixBufferJPEG;
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* VA_ENC_JPEG_H */
--- /dev/null
+++ src/gallium/state_trackers/va/va/va_enc_mpeg2.h
@@ -0,0 +1,287 @@
+/*
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/**
+ * \file va_enc_mpeg2.h
+ * \brief The MPEG-2 encoding API
+ *
+ * This file contains the \ref api_enc_mpeg2 "MPEG-2 encoding API".
+ */
+
+#ifndef _VA_ENC_MPEG2_H_
+#define _VA_ENC_MPEG2_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \defgroup api_enc_mpeg2 MPEG-2 encoding API
+ *
+ * @{
+ */
+
+/**
+ * \brief MPEG-2 Quantization Matrix Buffer
+ *
+ */
+typedef VAIQMatrixBufferMPEG2 VAQMatrixBufferMPEG2;
+
+/**
+ * \brief Packed header types specific to MPEG-2 encoding.
+ *
+ * Types of packed headers generally used for MPEG-2 encoding.
+ */
+typedef enum {
+    /**
+     * \brief Packed Sequence Parameter Set (SPS).
+     *
+     */
+    VAEncPackedHeaderMPEG2_SPS = VAEncPackedHeaderSequence,
+    /**
+     * \brief Packed Picture Parameter Set (PPS).
+     *
+     */
+    VAEncPackedHeaderMPEG2_PPS = VAEncPackedHeaderPicture,
+    /**
+     * \brief Packed slice header.
+     *
+     */
+    VAEncPackedHeaderMPEG2_Slice = VAEncPackedHeaderSlice,
+} VAEncPackedHeaderTypeMPEG2;
+
+/**
+ * \brief Sequence parameter for MPEG-2 encoding
+ *
+ * This structure holds information for \c sequence_header() and
+ * sequence_extension().
+ *
+ * If packed sequence headers mode is used, i.e. if the encoding
+ * pipeline was configured with the #VA_ENC_PACKED_HEADER_SEQUENCE
+ * flag, then the driver expects two more buffers to be provided to
+ * the same \c vaRenderPicture() as this buffer:
+ * - a #VAEncPackedHeaderParameterBuffer with type set to
+ *   VAEncPackedHeaderType::VAEncPackedHeaderSequence ;
+ * - a #VAEncPackedHeaderDataBuffer which holds the actual packed
+ *   header data.
+ *
+ */
+typedef struct _VAEncSequenceParameterBufferMPEG2 {
+    /** \brief Period between I frames. */
+    unsigned int intra_period;
+    /** \brief Period between I/P frames. */
+    unsigned int ip_period;
+    /** \brief Picture width.
+     *
+     * A 14bits unsigned inter, the lower 12bits 
+     * is horizontal_size_value, and the upper 
+     * 2bits is \c horizontal_size_extension
+     *
+     */
+    unsigned short picture_width;
+    /** \brief Picture height.
+     *
+     * A 14bits unsigned inter, the lower 12bits
+     * is vertical_size_value, and the upper 2bits is 
+     * vertical_size_size_extension
+     *
+     */
+    unsigned short picture_height;
+    /**
+     * \brief Initial bitrate set for this sequence in CBR or VBR modes.
+     *
+     * This field represents the initial bitrate value for this
+     * sequence if CBR or VBR mode is used, i.e. if the encoder
+     * pipeline was created with a #VAConfigAttribRateControl
+     * attribute set to either \ref VA_RC_CBR or \ref VA_RC_VBR.
+     *
+     * bits_per_second may be derived from bit_rate.
+     *
+     */
+    unsigned int bits_per_second;
+    /**
+     * \brief Frame rate
+     * 
+     * Derived from frame_rate_value, frame_rate_extension_n and 
+     * frame_rate_extension_d
+     *
+     */
+    float frame_rate;
+    /** \brief Same as the element in sequence_header() */
+    unsigned short aspect_ratio_information;
+    /** \brief Define the size of VBV */
+    unsigned int vbv_buffer_size;
+
+    union {
+        struct {
+            /** \brief Same as the element in Sequence extension() */
+            unsigned int profile_and_level_indication   : 8;
+            /** \brief Same as the element in Sequence extension() */
+            unsigned int progressive_sequence           : 1;
+            /** \brief Same as the element in Sequence extension() */
+            unsigned int chroma_format                  : 2;
+            /** \brief Same as the element in Sequence extension() */
+            unsigned int low_delay                      : 1;
+            /** \brief Same as the element in Sequence extension() */
+            unsigned int frame_rate_extension_n         : 2;
+            /** \brief Same as the element in Sequence extension() */
+            unsigned int frame_rate_extension_d         : 5;
+        } bits;
+        unsigned int value;
+    } sequence_extension;
+
+    /** \brief Flag to indicate the following GOP header are being updated */
+    unsigned int new_gop_header;
+
+    union {
+        struct {
+            /** \brief Time code */
+            unsigned int time_code                      : 25;
+            /** \brief Same as the element in GOP header */
+            unsigned int closed_gop                     : 1;
+            /** \brief SAme as the element in GOP header */
+            unsigned int broken_link                    : 1;
+        } bits;
+        unsigned int value;
+    } gop_header;
+} VAEncSequenceParameterBufferMPEG2;
+
+/**
+ * \brief Picture parameter for MPEG-2 encoding
+ *
+ * This structure holds information for picture_header() and 
+ * picture_coding_extension()
+ *
+ * If packed picture headers mode is used, i.e. if the encoding
+ * pipeline was configured with the #VA_ENC_PACKED_HEADER_PICTURE
+ * flag, then the driver expects two more buffers to be provided to
+ * the same \c vaRenderPicture() as this buffer:
+ * - a #VAEncPackedHeaderParameterBuffer with type set to
+ *   VAEncPackedHeaderType::VAEncPackedHeaderPicture ;
+ * - a #VAEncPackedHeaderDataBuffer which holds the actual packed
+ *   header data.
+ *
+ */
+typedef struct _VAEncPictureParameterBufferMPEG2 {
+    /** \brief Forward reference picture */
+    VASurfaceID forward_reference_picture;
+    /** \brief Backward reference picture */
+    VASurfaceID backward_reference_picture;
+    /** \brief Reconstructed(decoded) picture */
+    VASurfaceID reconstructed_picture;
+    /**
+     * \brief Output encoded bitstream.
+     *
+     * \ref coded_buf has type #VAEncCodedBufferType. It should be
+     * large enough to hold the compressed NAL slice and possibly SPS
+     * and PPS NAL units.
+     */
+    VABufferID coded_buf;
+    /**
+     * \brief Flag to indicate the picture is the last one or not.
+     *
+     * This fields holds 0 if the picture to be encoded is not 
+     * the last one in the stream. Otherwise, it 
+     * is \ref MPEG2_LAST_PICTURE_EOSTREAM.
+     */
+    unsigned char last_picture;
+    /** \brief Picture type */
+    VAEncPictureType picture_type;
+    /** \brief Same as the element in picture_header() */
+    unsigned int temporal_reference;
+    /** \brief Same as the element in picture_header() */
+    unsigned int vbv_delay;
+    /** \brief Same as the element in Picture coding extension */
+    unsigned char f_code[2][2];
+    union {
+        struct {
+            /** \brief Same as the element in Picture coding extension */
+            unsigned int intra_dc_precision             : 2; 
+            /** \brief Same as the element in Picture coding extension */
+            unsigned int picture_structure              : 2; 
+            /** \brief Same as the element in Picture coding extension */
+            unsigned int top_field_first                : 1; 
+            /** \brief Same as the element in Picture coding extension */
+            unsigned int frame_pred_frame_dct           : 1; 
+            /** \brief Same as the element in Picture coding extension */
+            unsigned int concealment_motion_vectors     : 1;
+            /** \brief Same as the element in Picture coding extension */
+            unsigned int q_scale_type                   : 1;
+            /** \brief Same as the element in Picture coding extension */
+            unsigned int intra_vlc_format               : 1;
+            /** \brief Same as the element in Picture coding extension */
+            unsigned int alternate_scan                 : 1;
+            /** \brief Same as the element in Picture coding extension */
+            unsigned int repeat_first_field             : 1;
+            /** \brief Same as the element in Picture coding extension */
+            unsigned int progressive_frame              : 1;
+            /** \brief Same as the element in Picture coding extension */
+            unsigned int composite_display_flag         : 1;
+        } bits;
+        unsigned int value;
+    } picture_coding_extension;
+
+    /* \brief Parameters for composite display
+     *
+     * Valid only when omposite_display_flag is 1
+     */
+    union {
+        struct {
+            /** \brief Same as the element in Picture coding extension */            
+            unsigned int v_axis                         : 1;
+            /** \brief Same as the element in Picture coding extension */
+            unsigned int field_sequence                 : 3;
+            /** \brief Same as the element in Picture coding extension */
+            unsigned int sub_carrier                    : 1;
+            /** \brief Same as the element in Picture coding extension */
+            unsigned int burst_amplitude                : 7;
+            /** \brief Same as the element in Picture coding extension */
+            unsigned int sub_carrier_phase              : 8;
+        } bits;
+        unsigned int value;
+    } composite_display;
+} VAEncPictureParameterBufferMPEG2;
+
+/**
+ * \brief Slice parameter for MPEG-2 encoding
+ *
+ */
+typedef struct _VAEncSliceParameterBufferMPEG2 {
+    /** \brief Starting MB address for this slice. */
+    unsigned int macroblock_address;
+    /** \brief Number of macroblocks in this slice. */
+    unsigned int num_macroblocks;
+    /** \brief Same as the element in slice() */
+    int quantiser_scale_code;
+    /** \brief Flag to indicate intra slice */
+    int is_intra_slice;
+} VAEncSliceParameterBufferMPEG2;
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _VA_ENC_MPEG2_H_ */
--- /dev/null
+++ src/gallium/state_trackers/va/va/va_enc_vp8.h
@@ -0,0 +1,330 @@
+/*
+ * Copyright (c) 2007-2012 Intel Corporation. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/**
+ * \file va_enc_vp8.h
+ * \brief VP8 encoding API
+ *
+ * This file contains the \ref api_enc_vp8 "VP8 encoding API".
+ */
+
+#ifndef VA_ENC_VP8_H
+#define VA_ENC_VP8_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \defgroup api_enc_vp8 VP8 encoding API
+ *
+ * @{
+ */
+
+/**
+ * \brief VP8 Encoding Sequence Parameter Buffer Structure
+ *
+ * This structure conveys sequence level parameters.
+ *
+ */
+typedef struct  _VAEncSequenceParameterBufferVP8
+{
+    /* frame width in pixels */
+    unsigned int frame_width;
+    /* frame height in pixels */
+    unsigned int frame_height;
+    /* horizontal scale */
+    unsigned int frame_width_scale;
+    /* vertical scale */
+    unsigned int frame_height_scale;
+
+    /* whether to enable error resilience features */
+    unsigned int error_resilient;
+    /* auto keyframe placement, non-zero means enable auto keyframe placement */
+    unsigned int kf_auto;
+    /* keyframe minimum interval */
+    unsigned int kf_min_dist;
+    /* keyframe maximum interval */
+    unsigned int kf_max_dist;
+
+
+    /* RC related fields. RC modes are set with VAConfigAttribRateControl */
+    /* For VP8, CBR implies HRD conformance and VBR implies no HRD conformance */
+
+    /**
+     * Initial bitrate set for this sequence in CBR or VBR modes.
+     *
+     * This field represents the initial bitrate value for this
+     * sequence if CBR or VBR mode is used, i.e. if the encoder
+     * pipeline was created with a #VAConfigAttribRateControl
+     * attribute set to either \ref VA_RC_CBR or \ref VA_RC_VBR.
+     *
+     * The bitrate can be modified later on through
+     * #VAEncMiscParameterRateControl buffers.
+     */
+    unsigned int bits_per_second;
+    /* Period between I frames. */
+    unsigned int intra_period;
+
+    /* reference and reconstructed frame buffers
+     * Used for driver auto reference management when configured through 
+     * VAConfigAttribEncAutoReference. 
+     */
+    VASurfaceID reference_frames[4];
+
+} VAEncSequenceParameterBufferVP8;
+
+
+/**
+ * \brief VP8 Encoding Picture Parameter Buffer Structure
+ *
+ * This structure conveys picture level parameters.
+ *
+ */
+typedef struct  _VAEncPictureParameterBufferVP8
+{
+    /* surface to store reconstructed frame  */
+    VASurfaceID reconstructed_frame;
+
+    /* 
+     * surfaces to store reference frames in non auto reference mode
+     * VA_INVALID_SURFACE can be used to denote an invalid reference frame. 
+     */
+    VASurfaceID ref_last_frame;
+    VASurfaceID ref_gf_frame;
+    VASurfaceID ref_arf_frame;
+
+    /* buffer to store coded data */
+    VABufferID coded_buf;
+
+    union {
+        struct {
+            /* force this frame to be a keyframe */
+            unsigned int force_kf                       : 1;
+            /* don't reference the last frame */
+            unsigned int no_ref_last                    : 1;
+            /* don't reference the golden frame */
+            unsigned int no_ref_gf                      : 1;
+            /* don't reference the alternate reference frame */
+            unsigned int no_ref_arf                     : 1;
+            unsigned int reserved                       : 28;
+        } bits;
+        unsigned int value;
+    } ref_flags;
+
+    union {
+        struct {
+            /* version */
+            unsigned int frame_type                     : 1;
+            unsigned int version                        : 3;
+            /* show_frame */
+            unsigned int show_frame                     : 1;
+            /* color_space */						   
+            unsigned int color_space                    : 1;
+            /*  0: bicubic, 1: bilinear, other: none */
+            unsigned int recon_filter_type              : 2;
+            /*  0: no loop fitler, 1: simple loop filter */
+            unsigned int loop_filter_type               : 2;
+            /* 0: disabled, 1: normal, 2: simple */
+            unsigned int auto_partitions                : 1;
+            /* same as log2_nbr_of_dct_partitions in frame header syntax */
+            unsigned int num_token_partitions           : 2;
+
+            /** 
+             * The following fields correspond to the same VP8 syntax elements 
+             * in the frame header.
+             */
+	    /**
+             * 0: clamping of reconstruction pixels is disabled,
+             * 1: clamping enabled.
+             */
+            unsigned int clamping_type                  : 1;
+            /* indicate segmentation is enabled for the current frame. */
+            unsigned int segmentation_enabled           : 1;
+            /**
+             * Determines if the MB segmentation map is updated in the current 
+             * frame.
+             */
+            unsigned int update_mb_segmentation_map     : 1;
+            /**
+             * Indicates if the segment feature data is updated in the current 
+             * frame.
+             */
+            unsigned int update_segment_feature_data    : 1;
+            /**
+             * indicates if the MB level loop filter adjustment is enabled for 
+             * the current frame (0 off, 1 on).  
+             */
+	    unsigned int loop_filter_adj_enable         : 1;
+            /**
+             * Determines whether updated token probabilities are used only for 
+             * this frame or until further update. 
+             * It may be used by application to enable error resilient mode. 
+             * In this mode probability updates are allowed only at Key Frames.
+             */
+            unsigned int refresh_entropy_probs          : 1;
+            /**
+             * Determines if the current decoded frame refreshes the golden frame.
+             */
+            unsigned int refresh_golden_frame           : 1;
+            /** 
+             * Determines if the current decoded frame refreshes the alternate 
+             * reference frame.
+             */
+            unsigned int refresh_alternate_frame        : 1;
+            /**
+             * Determines if the current decoded frame refreshes the last frame 
+             * reference buffer.
+             */
+            unsigned int refresh_last                   : 1;
+            /**
+             * Determines if the golden reference is replaced by another reference.
+             */
+            unsigned int copy_buffer_to_golden          : 2;
+            /**
+             * Determines if the alternate reference is replaced by another reference.
+             */
+            unsigned int copy_buffer_to_alternate       : 2;
+            /** 
+             * Controls the sign of motion vectors when the golden frame is referenced.  
+             */
+            unsigned int sign_bias_golden               : 1;
+            /**
+             * Controls the sign of motion vectors when the alternate frame is 
+             * referenced. 
+             */
+	    unsigned int sign_bias_alternate            : 1;
+            /**
+             * Enables or disables the skipping of macroblocks containing no 
+             * non-zero coefficients. 
+             */
+	    unsigned int mb_no_coeff_skip               : 1;
+            /** 
+             * Enforces unconditional per-MB loop filter delta update setting frame 
+             * header flags mode_ref_lf_delta_update, all mb_mode_delta_update_flag[4], 
+             * and all ref_frame_delta_update_flag[4] to 1. 
+	     * Since loop filter deltas are not automatically refreshed to default 
+             * values at key frames, dropped frame with delta update may prevent 
+             * correct decoding from the next key frame. 
+	     * Encoder application is advised to set this flag to 1 at key frames.
+	     */
+            unsigned int forced_lf_adjustment           : 1;
+            unsigned int reserved                       : 2;
+        } bits;
+        unsigned int value;
+    } pic_flags;
+
+    /**
+     * Contains a list of 4 loop filter level values (updated value if applicable)
+     * controlling the deblocking filter strength. Each entry represents a segment.
+     * When segmentation is disabled, use entry 0. 
+     * When loop_filter_level is 0, loop filter shall be disabled. 
+     */
+    char loop_filter_level[4];
+
+    /** 
+     * Contains a list of 4 delta values for reference frame based MB-level 
+     * loop filter adjustment.  
+     * If no update, then set to 0.
+     */
+    char ref_lf_delta[4];
+
+    /**
+     * Contains a list of 4 delta values for coding mode based MB-level loop
+     * filter adjustment.  
+     * If no update, then set to 0. 
+     */
+    char mode_lf_delta[4];
+	
+    /**
+     * Controls the deblocking filter sensitivity. 
+     * Corresponds to the same VP8 syntax element in frame header.
+     */
+    unsigned char sharpness_level;
+	
+    /** 
+     * Application supplied maximum clamp value for Qindex used in quantization.  
+     * Qindex will not be allowed to exceed this value.  
+     * It has a valid range [0..127] inclusive.  
+     */
+    unsigned char clamp_qindex_high;
+	
+    /**
+     * Application supplied minimum clamp value for Qindex used in quantization.  
+     * Qindex will not be allowed to be lower than this value.  
+     * It has a valid range [0..127] inclusive.  
+     * Condition clamp_qindex_low <= clamp_qindex_high must be guaranteed, 
+     * otherwise they are ignored. 
+     */
+    unsigned char clamp_qindex_low;
+	
+} VAEncPictureParameterBufferVP8;
+
+
+/**
+ * \brief VP8 MB Segmentation ID Buffer
+ *
+ * application provides buffer containing the initial segmentation id for each 
+ * MB, in raster scan order. Rate control may reassign it.
+ * For an 640x480 video, the buffer has 1200 entries. 
+ * the value of each entry should be in the range [0..3], inclusive.
+ * If segmentation is not enabled, application does not need to provide it. 
+ */
+typedef struct _VAEncMBMapBufferVP8
+{
+    /** 
+     * number of MBs in the frame.
+     * It is also the number of entries of mb_segment_id[];
+     */
+    unsigned int num_mbs;
+    /**
+     * per MB Segmentation ID Buffer
+     */
+    unsigned char *mb_segment_id;
+} VAEncMBMapBufferVP8;
+
+
+/**
+ * \brief VP8 Quantization Matrix Buffer Structure
+ *
+ * Contains quantization index for yac(0-3) for each segment and quantization 
+ * index deltas, ydc(0), y2dc(1), y2ac(2), uvdc(3), uvac(4) that are applied 
+ * to all segments.  When segmentation is disabled, only quantization_index[0] 
+ * will be used. This structure is sent once per frame.
+ */
+typedef struct _VAQMatrixBufferVP8
+{
+    unsigned short quantization_index[4];
+    short quantization_index_delta[5];
+} VAQMatrixBufferVP8;
+
+
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* VA_ENC_VP8_H */
--- /dev/null
+++ src/gallium/state_trackers/va/va/va_vpp.h
@@ -0,0 +1,750 @@
+/*
+ * Copyright (c) 2007-2011 Intel Corporation. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/**
+ * \file va_vpp.h
+ * \brief The video processing API
+ *
+ * This file contains the \ref api_vpp "Video processing API".
+ */
+
+#ifndef VA_VPP_H
+#define VA_VPP_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \defgroup api_vpp Video processing API
+ *
+ * @{
+ *
+ * The video processing API uses the same paradigm as for decoding:
+ * - Query for supported filters;
+ * - Set up a video processing pipeline;
+ * - Send video processing parameters through VA buffers.
+ *
+ * \section api_vpp_caps Query for supported filters
+ *
+ * Checking whether video processing is supported can be performed
+ * with vaQueryConfigEntrypoints() and the profile argument set to
+ * #VAProfileNone. If video processing is supported, then the list of
+ * returned entry-points will include #VAEntrypointVideoProc.
+ *
+ * \code
+ * VAEntrypoint *entrypoints;
+ * int i, num_entrypoints, supportsVideoProcessing = 0;
+ *
+ * num_entrypoints = vaMaxNumEntrypoints();
+ * entrypoints = malloc(num_entrypoints * sizeof(entrypoints[0]);
+ * vaQueryConfigEntrypoints(va_dpy, VAProfileNone,
+ *     entrypoints, &num_entrypoints);
+ *
+ * for (i = 0; !supportsVideoProcessing && i < num_entrypoints; i++) {
+ *     if (entrypoints[i] == VAEntrypointVideoProc)
+ *         supportsVideoProcessing = 1;
+ * }
+ * \endcode
+ *
+ * Then, the vaQueryVideoProcFilters() function is used to query the
+ * list of video processing filters.
+ *
+ * \code
+ * VAProcFilterType filters[VAProcFilterCount];
+ * unsigned int num_filters = VAProcFilterCount;
+ *
+ * // num_filters shall be initialized to the length of the array
+ * vaQueryVideoProcFilters(va_dpy, vpp_ctx, &filters, &num_filters);
+ * \endcode
+ *
+ * Finally, individual filter capabilities can be checked with
+ * vaQueryVideoProcFilterCaps().
+ *
+ * \code
+ * VAProcFilterCap denoise_caps;
+ * unsigned int num_denoise_caps = 1;
+ * vaQueryVideoProcFilterCaps(va_dpy, vpp_ctx,
+ *     VAProcFilterNoiseReduction,
+ *     &denoise_caps, &num_denoise_caps
+ * );
+ *
+ * VAProcFilterCapDeinterlacing deinterlacing_caps[VAProcDeinterlacingCount];
+ * unsigned int num_deinterlacing_caps = VAProcDeinterlacingCount;
+ * vaQueryVideoProcFilterCaps(va_dpy, vpp_ctx,
+ *     VAProcFilterDeinterlacing,
+ *     &deinterlacing_caps, &num_deinterlacing_caps
+ * );
+ * \endcode
+ *
+ * \section api_vpp_setup Set up a video processing pipeline
+ *
+ * A video processing pipeline buffer is created for each source
+ * surface we want to process. However, buffers holding filter
+ * parameters can be created once and for all. Rationale is to avoid
+ * multiple creation/destruction chains of filter buffers and also
+ * because filter parameters generally won't change frame after
+ * frame. e.g. this makes it possible to implement a checkerboard of
+ * videos where the same filters are applied to each video source.
+ *
+ * The general control flow is demonstrated by the following pseudo-code:
+ * \code
+ * // Create filters
+ * VABufferID denoise_filter, deint_filter;
+ * VABufferID filter_bufs[VAProcFilterCount];
+ * unsigned int num_filter_bufs;
+ *
+ * for (i = 0; i < num_filters; i++) {
+ *     switch (filters[i]) {
+ *     case VAProcFilterNoiseReduction: {       // Noise reduction filter
+ *         VAProcFilterParameterBuffer denoise;
+ *         denoise.type  = VAProcFilterNoiseReduction;
+ *         denoise.value = 0.5;
+ *         vaCreateBuffer(va_dpy, vpp_ctx,
+ *             VAProcFilterParameterBufferType, sizeof(denoise), 1,
+ *             &denoise, &denoise_filter
+ *         );
+ *         filter_bufs[num_filter_bufs++] = denoise_filter;
+ *         break;
+ *     }
+ *
+ *     case VAProcFilterDeinterlacing:          // Motion-adaptive deinterlacing
+ *         for (j = 0; j < num_deinterlacing_caps; j++) {
+ *             VAProcFilterCapDeinterlacing * const cap = &deinterlacing_caps[j];
+ *             if (cap->type != VAProcDeinterlacingMotionAdaptive)
+ *                 continue;
+ *
+ *             VAProcFilterParameterBufferDeinterlacing deint;
+ *             deint.type                   = VAProcFilterDeinterlacing;
+ *             deint.algorithm              = VAProcDeinterlacingMotionAdaptive;
+ *             vaCreateBuffer(va_dpy, vpp_ctx,
+ *                 VAProcFilterParameterBufferType, sizeof(deint), 1,
+ *                 &deint, &deint_filter
+ *             );
+ *             filter_bufs[num_filter_bufs++] = deint_filter;
+ *         }
+ *     }
+ * }
+ * \endcode
+ *
+ * Once the video processing pipeline is set up, the caller shall check the
+ * implied capabilities and requirements with vaQueryVideoProcPipelineCaps().
+ * This function can be used to validate the number of reference frames are
+ * needed by the specified deinterlacing algorithm, the supported color
+ * primaries, etc.
+ * \code
+ * // Create filters
+ * VAProcPipelineCaps pipeline_caps;
+ * VASurfaceID *forward_references;
+ * unsigned int num_forward_references;
+ * VASurfaceID *backward_references;
+ * unsigned int num_backward_references;
+ * VAProcColorStandardType in_color_standards[VAProcColorStandardCount];
+ * VAProcColorStandardType out_color_standards[VAProcColorStandardCount];
+ *
+ * pipeline_caps.input_color_standards      = NULL;
+ * pipeline_caps.num_input_color_standards  = ARRAY_ELEMS(in_color_standards);
+ * pipeline_caps.output_color_standards     = NULL;
+ * pipeline_caps.num_output_color_standards = ARRAY_ELEMS(out_color_standards);
+ * vaQueryVideoProcPipelineCaps(va_dpy, vpp_ctx,
+ *     filter_bufs, num_filter_bufs,
+ *     &pipeline_caps
+ * );
+ *
+ * num_forward_references  = pipeline_caps.num_forward_references;
+ * forward_references      =
+ *     malloc(num__forward_references * sizeof(VASurfaceID));
+ * num_backward_references = pipeline_caps.num_backward_references;
+ * backward_references     =
+ *     malloc(num_backward_references * sizeof(VASurfaceID));
+ * \endcode
+ *
+ * \section api_vpp_submit Send video processing parameters through VA buffers
+ *
+ * Video processing pipeline parameters are submitted for each source
+ * surface to process. Video filter parameters can also change, per-surface.
+ * e.g. the list of reference frames used for deinterlacing.
+ *
+ * \code
+ * foreach (iteration) {
+ *     vaBeginPicture(va_dpy, vpp_ctx, vpp_surface);
+ *     foreach (surface) {
+ *         VARectangle output_region;
+ *         VABufferID pipeline_buf;
+ *         VAProcPipelineParameterBuffer *pipeline_param;
+ *
+ *         vaCreateBuffer(va_dpy, vpp_ctx,
+ *             VAProcPipelineParameterBuffer, sizeof(*pipeline_param), 1,
+ *             NULL, &pipeline_buf
+ *         );
+ *
+ *         // Setup output region for this surface
+ *         // e.g. upper left corner for the first surface
+ *         output_region.x     = BORDER;
+ *         output_region.y     = BORDER;
+ *         output_region.width =
+ *             (vpp_surface_width - (Nx_surfaces + 1) * BORDER) / Nx_surfaces;
+ *         output_region.height =
+ *             (vpp_surface_height - (Ny_surfaces + 1) * BORDER) / Ny_surfaces;
+ *
+ *         vaMapBuffer(va_dpy, pipeline_buf, &pipeline_param);
+ *         pipeline_param->surface              = surface;
+ *         pipeline_param->surface_region       = NULL;
+ *         pipeline_param->output_region        = &output_region;
+ *         pipeline_param->output_background_color = 0;
+ *         if (first surface to render)
+ *             pipeline_param->output_background_color = 0xff000000; // black
+ *         pipeline_param->filter_flags         = VA_FILTER_SCALING_HQ;
+ *         pipeline_param->filters              = filter_bufs;
+ *         pipeline_param->num_filters          = num_filter_bufs;
+ *         vaUnmapBuffer(va_dpy, pipeline_buf);
+ *
+ *         // Update reference frames for deinterlacing, if necessary
+ *         pipeline_param->forward_references      = forward_references;
+ *         pipeline_param->num_forward_references  = num_forward_references_used;
+ *         pipeline_param->backward_references     = backward_references;
+ *         pipeline_param->num_backward_references = num_bacward_references_used;
+ *
+ *         // Apply filters
+ *         vaRenderPicture(va_dpy, vpp_ctx, &pipeline_buf, 1);
+ *     }
+ *     vaEndPicture(va_dpy, vpp_ctx);
+ * }
+ * \endcode
+ */
+
+/** \brief Video filter types. */
+typedef enum _VAProcFilterType {
+    VAProcFilterNone = 0,
+    /** \brief Noise reduction filter. */
+    VAProcFilterNoiseReduction,
+    /** \brief Deinterlacing filter. */
+    VAProcFilterDeinterlacing,
+    /** \brief Sharpening filter. */
+    VAProcFilterSharpening,
+    /** \brief Color balance parameters. */
+    VAProcFilterColorBalance,
+    /** \brief Skin Tone Enhancement. */
+    VAProcFilterSkinToneEnhancement,
+    VAProcFilterCount
+} VAProcFilterType;
+
+/** \brief Deinterlacing types. */
+typedef enum _VAProcDeinterlacingType {
+    VAProcDeinterlacingNone = 0,
+    /** \brief Bob deinterlacing algorithm. */
+    VAProcDeinterlacingBob,
+    /** \brief Weave deinterlacing algorithm. */
+    VAProcDeinterlacingWeave,
+    /** \brief Motion adaptive deinterlacing algorithm. */
+    VAProcDeinterlacingMotionAdaptive,
+    /** \brief Motion compensated deinterlacing algorithm. */
+    VAProcDeinterlacingMotionCompensated,
+    /** \brief Number of deinterlacing algorithms. */
+    VAProcDeinterlacingCount
+} VAProcDeinterlacingType;
+
+/** \brief Color balance types. */
+typedef enum _VAProcColorBalanceType {
+    VAProcColorBalanceNone = 0,
+    /** \brief Hue. */
+    VAProcColorBalanceHue,
+    /** \brief Saturation. */
+    VAProcColorBalanceSaturation,
+    /** \brief Brightness. */
+    VAProcColorBalanceBrightness,
+    /** \brief Contrast. */
+    VAProcColorBalanceContrast,
+    /** \brief Automatically adjusted saturation. */
+    VAProcColorBalanceAutoSaturation,
+    /** \brief Automatically adjusted brightness. */
+    VAProcColorBalanceAutoBrightness,
+    /** \brief Automatically adjusted contrast. */
+    VAProcColorBalanceAutoContrast,
+    /** \brief Number of color balance attributes. */
+    VAProcColorBalanceCount
+} VAProcColorBalanceType;
+
+/** \brief Color standard types. */
+typedef enum _VAProcColorStandardType {
+    VAProcColorStandardNone = 0,
+    /** \brief ITU-R BT.601. */
+    VAProcColorStandardBT601,
+    /** \brief ITU-R BT.709. */
+    VAProcColorStandardBT709,
+    /** \brief ITU-R BT.470-2 System M. */
+    VAProcColorStandardBT470M,
+    /** \brief ITU-R BT.470-2 System B, G. */
+    VAProcColorStandardBT470BG,
+    /** \brief SMPTE-170M. */
+    VAProcColorStandardSMPTE170M,
+    /** \brief SMPTE-240M. */
+    VAProcColorStandardSMPTE240M,
+    /** \brief Generic film. */
+    VAProcColorStandardGenericFilm,
+    /** \brief Number of color standards. */
+    VAProcColorStandardCount
+} VAProcColorStandardType;
+
+/** @name Video pipeline flags */
+/**@{*/
+/** \brief Specifies whether to apply subpictures when processing a surface. */
+#define VA_PROC_PIPELINE_SUBPICTURES    0x00000001
+/**
+ * \brief Specifies whether to apply power or performance
+ * optimizations to a pipeline.
+ *
+ * When processing several surfaces, it may be necessary to prioritize
+ * more certain pipelines than others. This flag is only a hint to the
+ * video processor so that it can omit certain filters to save power
+ * for example. Typically, this flag could be used with video surfaces
+ * decoded from a secondary bitstream.
+ */
+#define VA_PROC_PIPELINE_FAST           0x00000002
+/**@}*/
+
+/** @name Video filter flags */
+/**@{*/
+/** \brief Specifies whether the filter shall be present in the pipeline. */
+#define VA_PROC_FILTER_MANDATORY        0x00000001
+/**@}*/
+
+/** @name Pipeline end flags */
+/**@{*/
+/** \brief Specifies the pipeline is the last. */
+#define VA_PIPELINE_FLAG_END		0x00000004
+/**@}*/
+
+/** \brief Video processing pipeline capabilities. */
+typedef struct _VAProcPipelineCaps {
+    /** \brief Pipeline flags. See VAProcPipelineParameterBuffer::pipeline_flags. */
+    unsigned int        pipeline_flags;
+    /** \brief Extra filter flags. See VAProcPipelineParameterBuffer::filter_flags. */
+    unsigned int        filter_flags;
+    /** \brief Number of forward reference frames that are needed. */
+    unsigned int        num_forward_references;
+    /** \brief Number of backward reference frames that are needed. */
+    unsigned int        num_backward_references;
+    /** \brief List of color standards supported on input. */
+    VAProcColorStandardType *input_color_standards;
+    /** \brief Number of elements in \ref input_color_standards array. */
+    unsigned int        num_input_color_standards;
+    /** \brief List of color standards supported on output. */
+    VAProcColorStandardType *output_color_standards;
+    /** \brief Number of elements in \ref output_color_standards array. */
+    unsigned int        num_output_color_standards;
+} VAProcPipelineCaps;
+
+/** \brief Specification of values supported by the filter. */
+typedef struct _VAProcFilterValueRange {
+    /** \brief Minimum value supported, inclusive. */
+    float               min_value;
+    /** \brief Maximum value supported, inclusive. */
+    float               max_value;
+    /** \brief Default value. */
+    float               default_value;
+    /** \brief Step value that alters the filter behaviour in a sensible way. */
+    float               step;
+} VAProcFilterValueRange;
+
+/**
+ * \brief Video processing pipeline configuration.
+ *
+ * This buffer defines a video processing pipeline. As for any buffer
+ * passed to \c vaRenderPicture(), this is a one-time usage model.
+ * However, the actual filters to be applied are provided in the
+ * \c filters field, so they can be re-used in other processing
+ * pipelines.
+ *
+ * The target surface is specified by the \c render_target argument of
+ * \c vaBeginPicture(). The general usage model is described as follows:
+ * - \c vaBeginPicture(): specify the target surface that receives the
+ *   processed output;
+ * - \c vaRenderPicture(): specify a surface to be processed and composed
+ *   into the \c render_target. Use as many \c vaRenderPicture() calls as
+ *   necessary surfaces to compose ;
+ * - \c vaEndPicture(): tell the driver to start processing the surfaces
+ *   with the requested filters.
+ *
+ * If a filter (e.g. noise reduction) needs to be applied with different
+ * values for multiple surfaces, the application needs to create as many
+ * filter parameter buffers as necessary. i.e. the filter parameters shall
+ * not change between two calls to \c vaRenderPicture().
+ *
+ * For composition usage models, the first surface to process will generally
+ * use an opaque background color, i.e. \c output_background_color set with
+ * the most significant byte set to \c 0xff. For instance, \c 0xff000000 for
+ * a black background. Then, subsequent surfaces would use a transparent
+ * background color.
+ */
+typedef struct _VAProcPipelineParameterBuffer {
+    /**
+     * \brief Source surface ID.
+     *
+     * ID of the source surface to process. If subpictures are associated
+     * with the video surfaces then they shall be rendered to the target
+     * surface, if the #VA_PROC_PIPELINE_SUBPICTURES pipeline flag is set.
+     */
+    VASurfaceID         surface;
+    /**
+     * \brief Region within the source surface to be processed.
+     *
+     * Pointer to a #VARectangle defining the region within the source
+     * surface to be processed. If NULL, \c surface_region implies the
+     * whole surface.
+     */
+    const VARectangle  *surface_region;
+    /**
+     * \brief Requested input color primaries.
+     *
+     * Color primaries are implicitly converted throughout the processing
+     * pipeline. The video processor chooses the best moment to apply
+     * this conversion. The set of supported color primaries primaries
+     * for input shall be queried with vaQueryVideoProcPipelineCaps().
+     */
+    VAProcColorStandardType surface_color_standard;
+    /**
+     * \brief Region within the output surface.
+     *
+     * Pointer to a #VARectangle defining the region within the output
+     * surface that receives the processed pixels. If NULL, \c output_region
+     * implies the whole surface. 
+     *
+     * Note that any pixels residing outside the specified region will
+     * be filled in with the \ref output_background_color.
+     */
+    const VARectangle  *output_region;
+    /**
+     * \brief Background color.
+     *
+     * Background color used to fill in pixels that reside outside of the
+     * specified \ref output_region. The color is specified in ARGB format:
+     * [31:24] alpha, [23:16] red, [15:8] green, [7:0] blue.
+     *
+     * Unless the alpha value is zero or the \ref output_region represents
+     * the whole target surface size, implementations shall not render the
+     * source surface to the target surface directly. Rather, in order to
+     * maintain the exact semantics of \ref output_background_color, the
+     * driver shall use a temporary surface and fill it in with the
+     * appropriate background color. Next, the driver will blend this
+     * temporary surface into the target surface.
+     */
+    unsigned int        output_background_color;
+    /**
+     * \brief Requested output color primaries.
+     */
+    VAProcColorStandardType output_color_standard;
+    /**
+     * \brief Pipeline filters. See video pipeline flags.
+     *
+     * Flags to control the pipeline, like whether to apply subpictures
+     * or not, notify the driver that it can opt for power optimizations,
+     * should this be needed.
+     */
+    unsigned int        pipeline_flags;
+    /**
+     * \brief Extra filter flags. See vaPutSurface() flags.
+     *
+     * Filter flags are used as a fast path, wherever possible, to use
+     * vaPutSurface() flags instead of explicit filter parameter buffers.
+     *
+     * Allowed filter flags API-wise. Use vaQueryVideoProcPipelineCaps()
+     * to check for implementation details:
+     * - Bob-deinterlacing: \c VA_FRAME_PICTURE, \c VA_TOP_FIELD,
+     *   \c VA_BOTTOM_FIELD. Note that any deinterlacing filter
+     *   (#VAProcFilterDeinterlacing) will override those flags.
+     * - Color space conversion: \c VA_SRC_BT601, \c VA_SRC_BT709,
+     *   \c VA_SRC_SMPTE_240. 
+     * - Scaling: \c VA_FILTER_SCALING_DEFAULT, \c VA_FILTER_SCALING_FAST,
+     *   \c VA_FILTER_SCALING_HQ, \c VA_FILTER_SCALING_NL_ANAMORPHIC.
+     */
+    unsigned int        filter_flags;
+    /**
+     * \brief Array of filters to apply to the surface.
+     *
+     * The list of filters shall be ordered in the same way the driver expects
+     * them. i.e. as was returned from vaQueryVideoProcFilters().
+     * Otherwise, a #VA_STATUS_ERROR_INVALID_FILTER_CHAIN is returned
+     * from vaRenderPicture() with this buffer.
+     *
+     * #VA_STATUS_ERROR_UNSUPPORTED_FILTER is returned if the list
+     * contains an unsupported filter.
+     *
+     * Note: no filter buffer is destroyed after a call to vaRenderPicture(),
+     * only this pipeline buffer will be destroyed as per the core API
+     * specification. This allows for flexibility in re-using the filter for
+     * other surfaces to be processed.
+     */
+    VABufferID         *filters;
+    /** \brief Actual number of filters. */
+    unsigned int        num_filters;
+    /** \brief Array of forward reference frames. */
+    VASurfaceID        *forward_references;
+    /** \brief Number of forward reference frames that were supplied. */
+    unsigned int        num_forward_references;
+    /** \brief Array of backward reference frames. */
+    VASurfaceID        *backward_references;
+    /** \brief Number of backward reference frames that were supplied. */
+    unsigned int        num_backward_references;
+} VAProcPipelineParameterBuffer;
+
+/**
+ * \brief Filter parameter buffer base.
+ *
+ * This is a helper structure used by driver implementations only.
+ * Users are not supposed to allocate filter parameter buffers of this
+ * type.
+ */
+typedef struct _VAProcFilterParameterBufferBase {
+    /** \brief Filter type. */
+    VAProcFilterType    type;
+} VAProcFilterParameterBufferBase;
+
+/**
+ * \brief Default filter parametrization.
+ *
+ * Unless there is a filter-specific parameter buffer,
+ * #VAProcFilterParameterBuffer is the default type to use.
+ */
+typedef struct _VAProcFilterParameterBuffer {
+    /** \brief Filter type. */
+    VAProcFilterType    type;
+    /** \brief Value. */
+    float               value;
+} VAProcFilterParameterBuffer;
+
+/** @name De-interlacing flags */
+/**@{*/
+/** 
+ * \brief Bottom field first in the input frame. 
+ * if this is not set then assumes top field first.
+ */
+#define VA_DEINTERLACING_BOTTOM_FIELD_FIRST	0x0001
+/** 
+ * \brief Bottom field used in deinterlacing. 
+ * if this is not set then assumes top field is used.
+ */
+#define VA_DEINTERLACING_BOTTOM_FIELD		0x0002
+/** 
+ * \brief A single field is stored in the input frame. 
+ * if this is not set then assumes the frame contains two interleaved fields.
+ */
+#define VA_DEINTERLACING_ONE_FIELD		0x0004
+/**@}*/
+
+/** \brief Deinterlacing filter parametrization. */
+typedef struct _VAProcFilterParameterBufferDeinterlacing {
+    /** \brief Filter type. Shall be set to #VAProcFilterDeinterlacing. */
+    VAProcFilterType            type;
+    /** \brief Deinterlacing algorithm. */
+    VAProcDeinterlacingType     algorithm;
+    /** \brief Deinterlacing flags. */
+    unsigned int     		flags;
+} VAProcFilterParameterBufferDeinterlacing;
+
+/**
+ * \brief Color balance filter parametrization.
+ *
+ * This buffer defines color balance attributes. A VA buffer can hold
+ * several color balance attributes by creating a VA buffer of desired
+ * number of elements. This can be achieved by the following pseudo-code:
+ *
+ * \code
+ * enum { kHue, kSaturation, kBrightness, kContrast };
+ *
+ * // Initial color balance parameters
+ * static const VAProcFilterParameterBufferColorBalance colorBalanceParams[4] =
+ * {
+ *     [kHue] =
+ *         { VAProcFilterColorBalance, VAProcColorBalanceHue, 0.5 },
+ *     [kSaturation] =
+ *         { VAProcFilterColorBalance, VAProcColorBalanceSaturation, 0.5 },
+ *     [kBrightness] =
+ *         { VAProcFilterColorBalance, VAProcColorBalanceBrightness, 0.5 },
+ *     [kSaturation] =
+ *         { VAProcFilterColorBalance, VAProcColorBalanceSaturation, 0.5 }
+ * };
+ *
+ * // Create buffer
+ * VABufferID colorBalanceBuffer;
+ * vaCreateBuffer(va_dpy, vpp_ctx,
+ *     VAProcFilterParameterBufferType, sizeof(*pColorBalanceParam), 4,
+ *     colorBalanceParams,
+ *     &colorBalanceBuffer
+ * );
+ *
+ * VAProcFilterParameterBufferColorBalance *pColorBalanceParam;
+ * vaMapBuffer(va_dpy, colorBalanceBuffer, &pColorBalanceParam);
+ * {
+ *     // Change brightness only
+ *     pColorBalanceBuffer[kBrightness].value = 0.75;
+ * }
+ * vaUnmapBuffer(va_dpy, colorBalanceBuffer);
+ * \endcode
+ */
+typedef struct _VAProcFilterParameterBufferColorBalance {
+    /** \brief Filter type. Shall be set to #VAProcFilterColorBalance. */
+    VAProcFilterType            type;
+    /** \brief Color balance attribute. */
+    VAProcColorBalanceType      attrib;
+    /**
+     * \brief Color balance value.
+     *
+     * Special case for automatically adjusted attributes. e.g. 
+     * #VAProcColorBalanceAutoSaturation,
+     * #VAProcColorBalanceAutoBrightness,
+     * #VAProcColorBalanceAutoContrast.
+     * - If \ref value is \c 1.0 +/- \c FLT_EPSILON, the attribute is
+     *   automatically adjusted and overrides any other attribute of
+     *   the same type that would have been set explicitly;
+     * - If \ref value is \c 0.0 +/- \c FLT_EPSILON, the attribute is
+     *   disabled and other attribute of the same type is used instead.
+     */
+    float                       value;
+} VAProcFilterParameterBufferColorBalance;
+
+/**
+ * \brief Default filter cap specification (single range value).
+ *
+ * Unless there is a filter-specific cap structure, #VAProcFilterCap is the
+ * default type to use for output caps from vaQueryVideoProcFilterCaps().
+ */
+typedef struct _VAProcFilterCap {
+    /** \brief Range of supported values for the filter. */
+    VAProcFilterValueRange      range;
+} VAProcFilterCap;
+
+/** \brief Capabilities specification for the deinterlacing filter. */
+typedef struct _VAProcFilterCapDeinterlacing {
+    /** \brief Deinterlacing algorithm. */
+    VAProcDeinterlacingType     type;
+} VAProcFilterCapDeinterlacing;
+
+/** \brief Capabilities specification for the color balance filter. */
+typedef struct _VAProcFilterCapColorBalance {
+    /** \brief Color balance operation. */
+    VAProcColorBalanceType      type;
+    /** \brief Range of supported values for the specified operation. */
+    VAProcFilterValueRange      range;
+} VAProcFilterCapColorBalance;
+
+/**
+ * \brief Queries video processing filters.
+ *
+ * This function returns the list of video processing filters supported
+ * by the driver. The \c filters array is allocated by the user and
+ * \c num_filters shall be initialized to the number of allocated
+ * elements in that array. Upon successful return, the actual number
+ * of filters will be overwritten into \c num_filters. Otherwise,
+ * \c VA_STATUS_ERROR_MAX_NUM_EXCEEDED is returned and \c num_filters
+ * is adjusted to the number of elements that would be returned if enough
+ * space was available.
+ *
+ * The list of video processing filters supported by the driver shall
+ * be ordered in the way they can be iteratively applied. This is needed
+ * for both correctness, i.e. some filters would not mean anything if
+ * applied at the beginning of the pipeline; but also for performance
+ * since some filters can be applied in a single pass (e.g. noise
+ * reduction + deinterlacing).
+ *
+ * @param[in] dpy               the VA display
+ * @param[in] context           the video processing context
+ * @param[out] filters          the output array of #VAProcFilterType elements
+ * @param[in,out] num_filters the number of elements allocated on input,
+ *      the number of elements actually filled in on output
+ */
+VAStatus
+vaQueryVideoProcFilters(
+    VADisplay           dpy,
+    VAContextID         context,
+    VAProcFilterType   *filters,
+    unsigned int       *num_filters
+);
+
+/**
+ * \brief Queries video filter capabilities.
+ *
+ * This function returns the list of capabilities supported by the driver
+ * for a specific video filter. The \c filter_caps array is allocated by
+ * the user and \c num_filter_caps shall be initialized to the number
+ * of allocated elements in that array. Upon successful return, the
+ * actual number of filters will be overwritten into \c num_filter_caps.
+ * Otherwise, \c VA_STATUS_ERROR_MAX_NUM_EXCEEDED is returned and
+ * \c num_filter_caps is adjusted to the number of elements that would be
+ * returned if enough space was available.
+ *
+ * @param[in] dpy               the VA display
+ * @param[in] context           the video processing context
+ * @param[in] type              the video filter type
+ * @param[out] filter_caps      the output array of #VAProcFilterCap elements
+ * @param[in,out] num_filter_caps the number of elements allocated on input,
+ *      the number of elements actually filled in output
+ */
+VAStatus
+vaQueryVideoProcFilterCaps(
+    VADisplay           dpy,
+    VAContextID         context,
+    VAProcFilterType    type,
+    void               *filter_caps,
+    unsigned int       *num_filter_caps
+);
+
+/**
+ * \brief Queries video processing pipeline capabilities.
+ *
+ * This function returns the video processing pipeline capabilities. The
+ * \c filters array defines the video processing pipeline and is an array
+ * of buffers holding filter parameters.
+ *
+ * Note: the #VAProcPipelineCaps structure contains user-provided arrays.
+ * If non-NULL, the corresponding \c num_* fields shall be filled in on
+ * input with the number of elements allocated. Upon successful return,
+ * the actual number of elements will be overwritten into the \c num_*
+ * fields. Otherwise, \c VA_STATUS_ERROR_MAX_NUM_EXCEEDED is returned
+ * and \c num_* fields are adjusted to the number of elements that would
+ * be returned if enough space was available.
+ *
+ * @param[in] dpy               the VA display
+ * @param[in] context           the video processing context
+ * @param[in] filters           the array of VA buffers defining the video
+ *      processing pipeline
+ * @param[in] num_filters       the number of elements in filters
+ * @param[in,out] pipeline_caps the video processing pipeline capabilities
+ */
+VAStatus
+vaQueryVideoProcPipelineCaps(
+    VADisplay           dpy,
+    VAContextID         context,
+    VABufferID         *filters,
+    unsigned int        num_filters,
+    VAProcPipelineCaps *pipeline_caps
+);
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* VA_VPP_H */
